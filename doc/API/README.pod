=encoding UTF-8

=head1 NAME

marpaESLIF_API - Extended Marpa's Scanless Interface API

=head1 DESCRIPTION

marpaESLIF is a Scanless Interface expressed in a BNF format, that is using L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, itself being a thin interface on top of L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html> parser.

The whole API is available with this include:

  #include <marpaESLIF.h>

There are four namespaces:

=over

=item ESLIF

The main object.

=item ESLIFGrammar

Grammar creation and inspection.

=item ESLIFRecognizer

Parsing phase.

=item ESLIFValue

Valuation phase.

=back

and a transversal type:

  typedef struct marpaESLIFString {
    char   *bytep;            /* pointer bytes */
    size_t  bytel;            /* number of bytes */
    char   *encodingasciis;   /* Encoding of bytes, itself in ASCII encoding, NUL byte terminated */
    char   *asciis;           /* ASCII transliteration - never NULL if bytep is not NULL */
  } marpaESLIFString_t;

which describe what is a I<string>: this is a sequence of C<bytel> bytes, starting at C<bytep> in memory, in eventual C<encodingasciis> encoding, and transliterated as much as possible into C<asciis>.

=head2 ESLIF

Any application must start by instanciating a main ESLIF. This object is thread-safe, re-entrant, and can be reused as many times as needed, in contrary to other namespaces. The recommended usage is to create an ESLIF instance once for the entire process lifetime.

=head3 C<marpaESLIF_versions>

  const char *marpaESLIF_versions();

Returns a non-C<NULL> string describing the ESLIF version, in the form "MAJOR.MINOR.PATCH".

=head3 C<marpaESLIF_newp>

  typedef struct marpaESLIFOption {
    genericLogger_t *genericLoggerp;  /* Logger. Default: NULL */
  } marpaESLIFOption_t;

  marpaESLIF_t *marpaESLIF_newp(marpaESLIFOption_t *marpaESLIFOptionp);

This method is returning a C<marpaESLIF> object, or C<NULL> in case of failure. The parameter C<marpaESLIFOptionp> is a pointer to a C<marpaESLIFOption_t> structure, or C<NULL>. The C<marpaESLIFOption_t> has, as of this version, the single following component:

=over

=item C<genericLoggerp>

A pointer to a L<genericLogger|https://github.com/jddurand/c-genericLogger> instance. If it is C<NULL>, then ESLIF will never log. Otherwise, all namespaces will inherit this logger object and use it.

=back

=head3 C<marpaESLIF_versionb>

  short marpaESLIF_versionb(marpaESLIF_t *marpaESLIFp, char **versionsp);

Puts in C<versionsp>, if not C<NULL>, a pointer to a string containing ESLIF version.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIF_versionMajorb>

  short marpaESLIF_versionMajorb(marpaESLIF_t *marpaESLIFp, int *versionMajorip);

Puts in C<versionMajorip>, if not C<NULL>, the major version of ESLIF.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIF_versionMinorb>

  short marpaESLIF_versionMinorb(marpaESLIF_t *marpaESLIFp, int *versionMinorip);

Puts in C<versionMinorip>, if not C<NULL>, the minor version of ESLIF.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIF_versionPatchb>

  short marpaESLIF_versionPatchb(marpaESLIF_t *marpaESLIFp, int *versionPatchip);

Puts in C<versionPatchip>, if not C<NULL>, the patch version of ESLIF.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIF_extend_builtin_actionb>

  short marpaESLIF_extend_builtin_actionb(marpaESLIF_t *marpaESLIFp,
                                          char **actionsArrayp,
                                          size_t actionsArrayl);

ESLIF grammar built-in action names extension is possible using this method, where:

=over

=item C<actionsArrayp>

is a pointer to an array of new actions built-ins, defined as terminals as per the ESLIF grammar. Action extensions are always of type C<MARPAESLIF_ACTION_TYPE_NAME>.

=item C<actionsArrayl>

is the number of elements in the array.

=back

For example:

  static const char *actionsArrayp[] = {
    "'%[]'",
    "'%{}'",
    "'%undef'",
    "'%true'",
    "'%false'",
  };

  marpaESLIF_extend_builtin_actionb(marpaESLIFp, (char **) actionsArrayp, sizeof(actionsArrayp)/sizeof(actionsArrayp[0]))) {

will add C<%[]>, C<%{}> etc... built-in action names, that will I<not> be managed by ESLIF anyway, but by the caller's valuation callback: the action name is a parameter of this callback. The implementation is hardcoding every new buil-in as a new rule in the BNF in this form:

  <action name> ::= NEW_BUILTIN action => ::ascii

=head3 C<marpaESLIF_optionp>

  marpaESLIFOption_t *marpaESLIF_optionp(marpaESLIF_t *marpaESLIFp);

Returns the options used to create the C<marpaESLIFp> instance, or C<NULL> if failure. The returned pointer must I<never> be freed.

=head3 C<marpaESLIF_freev>

  void marpaESLIF_freev(marpaESLIF_t *marpaESLIFp);

The destructor of a marpaESLIF instance C<marpaESLIFp> instance. No-op if C<marpaESLIFp> is C<NULL>.

=head2 ESLIFGrammar

An I<ESLIFGrammar> is a sparse array of grammars, each is identified by a I<level>, that is the indice in this array, i.e. C<0>, C<1>, and so on.

Most of the APIs in this section have two forms, one for the I<current> grammar, one for a grammar at a wanted I<indice> or I<description>. A I<description> is a string identifying a grammar, set using the C<:desc> keyword, e.g.:

  :desc :[0]: 'Description of the grammar at level 0'
  :desc :[7]: 'Description of the grammar at level 7'

The default current grammar is always at level C<0>, that must exist. Level <0> is naturally considered like the I<top level> grammar. Nevertheless it is possible to instanciate a parsing at a I<different> level, then the I<current grammar> in derived namespaces like the recognizer or the valuation is I<the level you asked for>. For example:

  A :[0]:= X          # Could have been A ::= X, '::=' is an alias for ':[0]:'
  X :[1]:= Y@+2       # Could have been X ~ Y@+2, '~' is an alias for ':[1]:'
  Y :[3]:= 'Z'

declares grammars at level C<0>, C<1> and C<3>. Grammar at level C<2> is undefined.

=head3 C<marpaESLIFGrammar_newp>

  typedef struct marpaESLIFGrammarOption {
    void   *bytep;               /* Input */
    size_t  bytel;               /* Input length in byte unit */
    char   *encodings;           /* Input encoding. Default: NULL */
    size_t  encodingl;           /* Length of encoding itself. Default: 0 */
  } marpaESLIFGrammarOption_t;

  marpaESLIFGrammar_t *marpaESLIFGrammar_newp(marpaESLIF_t              *marpaESLIFp,
                                              marpaESLIFGrammarOption_t *marpaESLIFGrammarOptionp);

Creates a grammar object instance, with parameters:

=over

=item C<marpaESLIFp>

An <required> ESLIF object instance.

=item C<marpaESLIFGrammarOptionp>

A I<required> pointer to a C<marpaESLIFGrammarOption_t> structure, defined as:

=over

=item C<bytep>

A pointer to the start of the grammar. Must be non-NULL.

=item C<bytel>

Number of B<bytes>. Must be > 0.

=item C<encodings>

Pointer to a buffer containing encoding information of the grammar, in ASCII. Can be NULL.

=item C<encodingl>

Number of bytes of the buffer containing encoding information. Can be 0.

=back

=back

Grammars themselves are assumed to always fit within a single block of memory. So there is no I<grammar reader> here: we assume that a single buffer starting at C<bytep>, spanning over C<bytel> bytes, is always possible and enough for a grammar definition.

Returns C<NULL> if failure, a grammar object instance on success.

=head3 C<marpaESLIFGrammar_eslifp>

  marpaESLIF_t *marpaESLIFGrammar_eslifp(marpaESLIFGrammar_t *marpaESLIFGrammarp);

Returns the ESLIF parent object instance of C<marpaESLIFGrammarp>, or C<NULL> if failure. It never returns C<NULL> if C<marpaESLIFGrammarp> is not C<NULL>.

=head3 C<marpaESLIFGrammar_optionp>

  marpaESLIFGrammarOption_t *marpaESLIFGrammar_optionp(marpaESLIFGrammar_t *marpaESLIFGrammarp);

Returns the options used to create the C<marpaESLIFGrammarp> instance, or C<NULL> if failure. The returned pointer must I<never> be freed.

=head3 C<marpaESLIFGrammar_ngrammarib>

  short marpaESLIFGrammar_ngrammarib(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                     int                 *ngrammarip);

Puts the number of sub-grammars in the value pointed by C<ngrammarip>, which can be C<NULL>. The number of grammars is the highest level plus one, and it is B<allowed> to have undefined grammars at any indice but level 0. For example:

  A :[0]:= X          # First grammar
  X :[1]:= Y@+2       # Second grammar
                      # Third grammar (undefined)
  Y :[3]:= 'Z'        # Fourth grammar

would return C<4>: there are four grammars, the third one being undefined.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_defaultsb>

  typedef enum marpaESLIFActionType {
    MARPAESLIF_ACTION_TYPE_NAME = 0,
    MARPAESLIF_ACTION_TYPE_STRING,
    MARPAESLIF_ACTION_TYPE_LUA,
  } marpaESLIFActionType_t;

  typedef struct marpaESLIFAction {
    marpaESLIFActionType_t type;
    union {
      char               *names;
      marpaESLIFString_t *stringp;
      char               *luas;
    } u;
  } marpaESLIFAction_t;

  typedef struct marpaESLIFGrammarDefaults {
    marpaESLIFAction_t *defaultRuleActionp;   /* Default action for rules */
    marpaESLIFAction_t *defaultSymbolActionp; /* Default action for symbols */
    marpaESLIFAction_t *defaultEventActionp;  /* Default action for events */
    marpaESLIFAction_t *defaultRegexActionp;  /* Default action for regex */
    char               *defaultEncodings;     /* Default encoding */
    char               *fallbackEncodings;    /* Fallback encoding */
  } marpaESLIFGrammarDefaults_t;

  short marpaESLIFGrammar_defaultsb(marpaESLIFGrammar_t         *marpaESLIFGrammarp,
                                    marpaESLIFGrammarDefaults_t *marpaESLIFGrammarDefaultsp);

Puts in the structure pointed by C<marpaESLIFGrammarDefaultsp>, if it is not C<NULL>, the current grammar defaults, all of them being a structure of type C<marpaESLIFAction_t> or C<NULL> when not set. An action can be of two types:

=over

=item C<MARPAESLIF_ACTION_TYPE_NAME>

A named action, that the end-user will be responsible to resolve to valid a function pointer. Action name itself is an ASCII NUL terminated string accessible in C<u.names>.

=item C<MARPAESLIF_ACTION_TYPE_STRING>

A string literal. Then the action result is forced to be the UTF-8 corresponding string, always pushed with type C<MARPAESLIF_VALUE_TYPE_ARRAY> on the stack. String literals are illegals for the free action, legal for rule and symbol actions. String itself is a C<marpaESLIFString_t> structure pointer accessible in C<u.stringp>.

=item C<MARPAESLIF_ACTION_TYPE_LUA>

A string literal. Then the action result is forced to be a lua function, using an embedded lua interpreter that ESLIF provides. Such function should be enclosed in a statement like e.g.:

  <luascript>
    function thefunction(arguments)
    end
  </luascript>

where there will be as many arguments as there are Right-Hand side values.

=back

=over

=item defaultRuleActionp

Default action for symbols, and correspond to the grammar keyword C<action>. Can be a name of a string literal.

=item defaultSymbolActionp
Default action for symbols, and correspond to the grammar keyword C<symbol-action>. Can be a name of a string literal.

=item defaultEventActionp
Default action for events, and correspond to the grammar keyword C<event-action>. Can be a name of a string literal.

=item defaultRegexActionp
Default action for regex callout, and correspond to the grammar keyword C<regex-action>. Can be a name of a string literal.

=back

The keywords mentionned upper are set within a I<:default> statement, e.g.:

  :default ::= action        => myRuleAction
               symbol-action => ::u8"String Literal"

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_defaults_by_levelb>

  short marpaESLIFGrammar_defaults_by_levelb(marpaESLIFGrammar_t         *marpaESLIFGrammarp,
                                             marpaESLIFGrammarDefaults_t *marpaESLIFGrammarDefaultsp,
                                             int                          leveli,
                                             marpaESLIFString_t          *descp);

Put in the structure pointed by C<marpaESLIFGrammarDefaultsp>, if it is not C<NULL>, the grammar at level C<leveli> and/or description C<descp> defaults, where a C<NULL> value for a default means it is not set.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_defaults_setb>

  short marpaESLIFGrammar_defaults_setb(marpaESLIFGrammar_t         *marpaESLIFGrammarp,
                                        marpaESLIFGrammarDefaults_t *marpaESLIFGrammarDefaultsp);

Sets all grammar defaults using the structure pointed by C<marpaESLIFGrammarDefaultsp>, if it is not C<NULL>. A C<NULL> value for a default has the same effect as if original grammar never had the associated keyword.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_defaults_by_level_setb>

  short marpaESLIFGrammar_defaults_by_level_setb(marpaESLIFGrammar_t         *marpaESLIFGrammarp,
                                                 marpaESLIFGrammarDefaults_t *marpaESLIFGrammarDefaultsp,
                                                 int                          leveli,
                                                 marpaESLIFString_t          *descp);

Puts in the structure pointed by C<marpaESLIFGrammarDefaultsp>, if it is not C<NULL>. A C<NULL> value for a default has the same effect as if original grammar never had the associated keyword.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammar_by_levelb>

  short marpaESLIFGrammar_grammar_by_levelb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                            int                  leveli,
                                            marpaESLIFString_t  *descp,
                                            int                 *levelip,
                                            marpaESLIFString_t **descpp);

Put in the values pointed by C<levelip> and C<descpp>, which can be both C<NULL>, the level and description of wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if lower than C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

When both C<leveli> and C<descp> are set, C<descp> have precedence over C<leveli>.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammarproperty_currentb>

  typedef struct marpaESLIFGrammarProperty {
    int                    leveli;                       /* Grammar level */
    marpaESLIFString_t    *descp;                        /* Grammar description (auto-generated if none) */
    short                  latmb;                        /* LATM ? */
    marpaESLIFAction_t    *defaultSymbolActionp;         /* Default action for symbols - never NULL */
    marpaESLIFAction_t    *defaultRuleActionp;           /* Default action for rules - never NULL */
    marpaESLIFAction_t    *defaultEventActionp;          /* Default action for event - can be NULL */
    marpaESLIFAction_t    *defaultRegexActionp;          /* Default action for regex - can be NULL */
    int                    starti;                       /* Start symbol Id - always >= 0 */
    int                    discardi;                     /* Discard symbol Id (-1 if none) */
    size_t                 nsymboll;                     /* Number of symbols - always > 0*/
    int                   *symbolip;                     /* Array of symbols Ids - never NULL */
    size_t                 nrulel;                       /* Number of rules - always > 0*/
    int                   *ruleip;                       /* Array of rule Ids - never NULL */
  } marpaESLIFGrammarProperty_t;

  marpaESLIFGrammar_grammarproperty_currentb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                             marpaESLIFGrammarProperty_t *grammarPropertyp);

Put in the value pointed by C<grammarPropertyp>, if it is not C<NULL>, current C<marpaESLIFGrammarp>'s grammar properties.

=head3 C<marpaESLIFGrammar_grammarproperty_by_levelb>

  marpaESLIFGrammar_grammarproperty_by_levelb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                              marpaESLIFGrammarProperty_t *grammarPropertyp,
                                              int leveli,
                                              marpaESLIFString_t *descp);

Put in the value pointed by C<grammarPropertyp>, if it is not C<NULL>, C<marpaESLIFGrammarp>'s grammar's at level C<leveli> or with description C<descp> properties.

=head3 C<marpaESLIFGrammar_rulearray_currentb>

  short marpaESLIFGrammar_rulearray_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                             int                 **ruleipp,
                                             size_t               *rulelp);

Puts in the values pointed by C<ruleipp> and C<rulelp> a pointer to an array of integer, and the number of them, respectively, of current grammar. User must B<not> try to free C<*ruleipp>. Please note that this is exactly the same information as the tuple C<{nrulel,ruleip>} returned by C<marpaESLIFGrammar_grammarproperty_currentb>.

Returns a true value on failure, a false value on failure. C<*ruleipp> is never C<NULL> in case of success.

=head3 C<marpaESLIFGrammar_rulearray_by_levelb>

  short marpaESLIFGrammar_rulearray_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                              int                 **ruleipp,
                                              size_t               *rulelp,
                                              int                   leveli,
                                              marpaESLIFString_t   *descp);


Put in the values pointed by C<ruleipp> and C<rulelp> a pointer to an array of integer, and the number of them, respectively, of the grammar referenced by C<leveli> or C<descp>. 

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if lower than C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

When both C<leveli> and C<descp> are set, C<descp> have precedence over C<leveli>.

Returns a true value on failure, a false value on failure. C<*ruleipp> is never C<NULL> in case of success.

=head3 C<marpaESLIFGrammar_ruleproperty_currentb>

  typedef enum marpaESLIFRulePropertyBit {
    MARPAESLIF_RULE_IS_ACCESSIBLE = 0x01,
    MARPAESLIF_RULE_IS_NULLABLE   = 0x02,
    MARPAESLIF_RULE_IS_NULLING    = 0x04,
    MARPAESLIF_RULE_IS_LOOP       = 0x08,
    MARPAESLIF_RULE_IS_PRODUCTIVE = 0x10
  } marpaESLIFRulePropertyBit_t;

  typedef struct marpaESLIFRuleProperty {
    int                    idi;                          /* Rule Id */
    marpaESLIFString_t    *descp;                        /* Rule alternative name (auto-generated if none) */
    char                  *asciishows;                   /* Rule show (ASCII) */
    int                    lhsi;                         /* LHS symbol Id */
    int                    separatori;                   /* Eventual separator symbol Id (-1 if none) */
    size_t                 nrhsl;                        /* Number of RHS, 0 in case of a nullable */
    int                   *rhsip;                        /* Array of RHS Ids, NULL in case of a nullable */
    int                    exceptioni;                   /* Exception symbol Id (-1 if none) */
    marpaESLIFAction_t    *actionp;                      /* Action */
    char                  *discardEvents;                /* Discard event name - shallowed with its RHS */
    short                  discardEventb;                /* Discard event initial state: 0: off, 1: on */
    int                    ranki;                        /* Rank */
    short                  nullRanksHighb;               /* Null ranks high ? */
    short                  sequenceb;                    /* Sequence ? */
    short                  properb;                      /* Proper ? */
    int                    minimumi;                     /* minimum in case of sequence ? */
    short                  internalb;                    /* This rule is internal */
    int                    propertyBitSet;               /* C.f. marpaESLIFRulePropertyBit_t */
  } marpaESLIFRuleProperty_t;


  short marpaESLIFGrammar_ruleproperty_currentb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                int rulei,
                                                marpaESLIFRuleProperty_t *rulePropertyp);

Puts in the value pointed by C<rulePropertyp>, if it is not C<NULL>, properties of rule number C<rulei> of current C<marpaESLIFGrammarp>'s grammar.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_ruleproperty_by_levelb>

  short marpaESLIFGrammar_ruleproperty_by_levelb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                 int rulei,
                                                 marpaESLIFRuleProperty_t *rulePropertyp,
                                                 int leveli,
                                                 marpaESLIFString_t *descp);

Puts in the value pointed by C<rulePropertyp>, if it is not C<NULL>, properties of rule number C<rulei> of C<marpaESLIFGrammarp>'s grammar's level C<leveli> or description C<descp>.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_ruledisplayform_currentb>

  short marpaESLIFGrammar_ruledisplayform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                   int                   rulei,
                                                   char                **ruledisplaysp);

Put in the value pointed by C<ruledisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of rule name at indice C<rulei> of the current grammar.

Returns a true value on failure, a false value on failure.

Example of a rule display form:

  <lstring>

=head3 C<marpaESLIFGrammar_ruledisplayform_by_levelb>

  short marpaESLIFGrammar_ruledisplayform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                    int                   rulei,
                                                    char                **ruledisplaysp,
                                                    int                   leveli,
                                                    marpaESLIFString_t   *descp);

Put in the value pointed by C<ruledisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of rule name at indice C<rulei> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_symbolarray_currentb>

  short marpaESLIFGrammar_symbolarray_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                               int                 **symbolipp,
                                               size_t               *symbollp);

Puts in the values pointed by C<symbolipp> and C<symbollp> a pointer to an array of integer, and the number of them, respectively, of current grammar. User must B<not> try to free C<*symbolipp>. Please note that this is exactly the same information as the tuple C<{nsymboll,symbolip>} returned by C<marpaESLIFGrammar_grammarproperty_currentb>.

Returns a true value on failure, a false value on failure. C<*symbolipp> is never C<NULL> in case of success.

=head3 C<marpaESLIFGrammar_symbolarray_by_levelb>

  short marpaESLIFGrammar_symbolarray_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                int                 **symbolipp,
                                                size_t               *symbollp,
                                                int                   leveli,
                                                marpaESLIFString_t   *descp);


Put in the values pointed by C<symbolipp> and C<symbollp> a pointer to an array of integer, and the number of them, respectively, of the grammar referenced by C<leveli> or C<descp>. 

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if lower than C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

When both C<leveli> and C<descp> are set, C<descp> have precedence over C<leveli>.

Returns a true value on failure, a false value on failure. C<*symbolipp> is never C<NULL> in case of success.

=head3 C<marpaESLIFGrammar_symbolproperty_currentb>

  typedef enum marpaESLIFSymbolPropertyBit {
    MARPAESLIF_SYMBOL_IS_ACCESSIBLE = 0x01,
    MARPAESLIF_SYMBOL_IS_NULLABLE   = 0x02,
    MARPAESLIF_SYMBOL_IS_NULLING    = 0x04,
    MARPAESLIF_SYMBOL_IS_PRODUCTIVE = 0x08,
    MARPAESLIF_SYMBOL_IS_START      = 0x10,
    MARPAESLIF_SYMBOL_IS_TERMINAL   = 0x20
  } marpaESLIFSymbolPropertyBit_t;

  typedef enum marpaESLIFSymbolType {
    MARPAESLIF_SYMBOLTYPE_TERMINAL,
    MARPAESLIF_SYMBOLTYPE_META
  } marpaESLIFSymbolType_t;

  typedef struct marpaESLIFSymbolProperty {
    marpaESLIFSymbolType_t       type;                   /* Symbol type */
    short                        startb;                 /* Start symbol ? */
    short                        discardb;               /* Discard LHS symbol (i.e. :discard) ? */
    short                        discardRhsb;            /* Discard RHS symbol ? */
    short                        lhsb;                   /* Is an LHS somewhere in its grammar ? */
    short                        topb;                   /* Is a top-level symbol in its grammar - implies lhsb */
    int                          idi;                    /* Marpa ID */
    marpaESLIFString_t          *descp;                  /* Symbol description */
    char                        *eventBefores;           /* Pause before */
    short                        eventBeforeb;           /* Pause before initial state: 0: off, 1: on */
    char                        *eventAfters;            /* Pause after */
    short                        eventAfterb;            /* Pause after initial state: 0: off, 1: on */
    char                        *eventPredicteds;        /* Event name for prediction */
    short                        eventPredictedb;        /* Prediction initial state: 0: off, 1: on */
    char                        *eventNulleds;           /* Event name for nulled */
    short                        eventNulledb;           /* Nulled initial state: 0: off, 1: on */
    char                        *eventCompleteds;        /* Event name for completion */
    short                        eventCompletedb;        /* Completion initial state: 0: off, 1: on */
    char                        *discardEvents;          /* Discard event name - shallow pointer to a :discard rule's discardEvents */
    short                        discardEventb;          /* Discard event initial state: 0: off, 1: on - copy of :discard's rule value */
    int                          lookupResolvedLeveli;   /* Resolved grammar level */
    int                          priorityi;              /* Symbol priority */
    marpaESLIFAction_t          *nullableActionp;        /* Nullable semantic */
    int                          propertyBitSet;
    int                          eventBitSet;
    marpaESLIFAction_t          *symbolActionp;          /* Symbol specific action */
    marpaESLIFAction_t          *ifActionp;              /* Symbol if action */
  } marpaESLIFSymbolProperty_t;

  short marpaESLIFGrammar_symbolproperty_currentb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                  int symboli,
                                                  marpaESLIFSymbolProperty_t *symbolPropertyp);

Puts in the value pointed by C<symbolPropertyp>, if it is not C<NULL>, properties of symbol number C<symboli> of current C<marpaESLIFGrammarp>'s grammar.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_symbolproperty_by_levelb>

  short marpaESLIFGrammar_symbolproperty_by_levelb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                   int symboli,
                                                   marpaESLIFSymbolProperty_t *symbolPropertyp,
                                                   int leveli,
                                                   marpaESLIFString_t *descp);

Puts in the value pointed by C<symbolPropertyp>, if it is not C<NULL>, properties of symbol number C<symboli> of C<marpaESLIFGrammarp>'s grammar's level C<leveli> or description C<descp>.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_symboldisplayform_currentb>

  short marpaESLIFGrammar_symboldisplayform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                     int                   symboli,
                                                     char                **symboldisplaysp);

Put in the value pointed by C<symboldisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of symbol name at indice C<symboli> of the current grammar from C<marpaESLIFGrammarp>.

Return a true value on failure, a false value on failure.

Example of a symbol display form:

  <in_string>

=head3 C<marpaESLIFGrammar_symboldisplayform_by_levelb>

  short marpaESLIFGrammar_symboldisplayform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                      int                   symboli,
                                                      char                **symboldisplaysp,
                                                      int                   leveli,
                                                      marpaESLIFString_t   *descp);

Put in the value pointed by C<symboldisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of symbol name at indice C<symboli> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_ruleshowform_currentb>

  short marpaESLIFGrammar_ruleshowform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                int                   rulei,
                                                char                **ruleshowsp);

Put in the value pointed by C<ruleshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of rule definition at indice C<rulei> of the current grammar from C<marpaESLIFGrammarp>.

Return a true value on failure, a false value on failure.

Example of a rule show form:

  <lstring> ~ <quote> <in_string> <quote>

=head3 C<marpaESLIFGrammar_ruleshowform_by_levelb>

  short marpaESLIFGrammar_ruleshowform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                    int                   rulei,
                                                    char                **ruleshowsp,
                                                    int                   leveli,
                                                    marpaESLIFString_t   *descp);

Put in the value pointed by C<ruleshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of rule definition at indice C<rulei> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammarshowform_currentb>

  short marpaESLIFGrammar_grammarshowform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                   int                   grammari,
                                                   char                **grammarshowsp);

Put in the value pointed by C<grammarshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of grammar definition at indice C<grammari> of the current grammar from C<marpaESLIFGrammarp>. This is very exhaustive, and give internal information about all symbols and rules. See the NOTES section.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammarshowform_by_levelb>

  short marpaESLIFGrammar_grammarshowform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                    int                   grammari,
                                                    char                **grammarshowsp,
                                                    int                   leveli,
                                                    marpaESLIFString_t   *descp);

Put in the value pointed by C<grammarshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of grammar definition at indice C<grammari> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

This is very exhaustive, and give internal information about all symbols and rules. See the NOTES section.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammarshowscriptb>

  short marpaESLIFGrammar_grammarshowscriptb(marpaESLIFGrammar_t *marpaESLIFGrammarp, char **grammarscriptsp);

Put in the value pointed by C<grammarscriptsp>, which can be C<NULL>, a NUL-terminated ASCII string containing all lua statements.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_parseb>

  short marpaESLIFGrammar_parseb(marpaESLIFGrammar_t          *marpaESLIFGrammarp,
                                 marpaESLIFRecognizerOption_t *marpaESLIFRecognizerOptionp,
                                 marpaESLIFValueOption_t      *marpaESLIFValueOptionp,
                                 short                        *isExhaustedbp,
                                 marpaESLIFValueResult_t      *marpaESLIFValueResultp);

Please refer to the documentation of:

=over

=item C<marpaESLIFGrammar_newp>

for the C<marpaESLIFRecognizerOption_t> structure documentation.

=item C<ESLIF Value Result>

for the C<marpaESLIFValueResult_t> structure documentation.

=item C<marpaESLIFValue_newp>

for the C<marpaESLIFValueOption_t> structures documentation.

=back

A short form of parsing and valuation, in which I<no event> is possible: the entire scanning is left to the marpaESLIF engine. The grammar at level C<0> is used.

The value pointed by C<isExhaustedbp>, when not C<NULL>, is filled with a true value if the parsing exhausted (exhaustion roughly mean that the parsing stopped without consuming all the data), a false value otherwise. This flag does not depend on the existence of an exhaustion event or not.

Returns a true value on success, a false value otherwise.

=head3 C<marpaESLIFGrammar_parse_by_levelb>

  short marpaESLIFGrammar_parse_by_levelb(marpaESLIFGrammar_t          *marpaESLIFGrammarp,
                                          marpaESLIFRecognizerOption_t *marpaESLIFRecognizerOptionp,
                                          marpaESLIFValueOption_t      *marpaESLIFValueOptionp,
                                          short                        *isExhaustedbp,
                                          int                           leveli,
                                          marpaESLIFString_t           *descp,
                                          marpaESLIFValueResult_t      *marpaESLIFValueResultp);

Same functionnality as C<marpaESLIFGrammar_parseb> for a wanted grammar from C<marpaESLIFGrammarp>, with these additional parameters:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

=head3 C<marpaESLIFGrammar_freev>

  void marpaESLIFGrammar_freev(marpaESLIFGrammar_t *marpaESLIFGrammarp);

The destructor of a marpaESLIFGrammar instance C<marpaESLIFGrammarp> instance. No-op if C<marpaESLIFGrammarp> is C<NULL>.

=head2 ESLIF Value Result

Before going on with the recognizer and valation namespaces, the notion of value result should be explicited first.

A Value result holds two notions:

=over

=item A value type

=item How the value is I<represented>

=back

Supported value types are in the enumeration C<marpaESLIFValueType_t>:

  typedef enum marpaESLIFValueType {
    MARPAESLIF_VALUE_TYPE_UNDEF = 0,
    MARPAESLIF_VALUE_TYPE_CHAR,
    MARPAESLIF_VALUE_TYPE_SHORT,
    MARPAESLIF_VALUE_TYPE_INT,
    MARPAESLIF_VALUE_TYPE_LONG,
    MARPAESLIF_VALUE_TYPE_FLOAT,
    MARPAESLIF_VALUE_TYPE_DOUBLE,
    MARPAESLIF_VALUE_TYPE_PTR,
    MARPAESLIF_VALUE_TYPE_ARRAY,
    MARPAESLIF_VALUE_TYPE_BOOL,
    MARPAESLIF_VALUE_TYPE_STRING,
    MARPAESLIF_VALUE_TYPE_ROW,
    MARPAESLIF_VALUE_TYPE_TABLE,
    MARPAESLIF_VALUE_TYPE_LONG_DOUBLE
  #ifdef MARPAESLIF_HAVE_LONG_LONG
    ,MARPAESLIF_VALUE_TYPE_LONG_LONG
  #endif
  } marpaESLIFValueType_t;

The names are quite explicit:

=over

=item MARPAESLIF_VALUE_TYPE_UNDEF

Value is undefined.

=item MARPAESLIF_VALUE_TYPE_CHAR

Value type is C<marpaESLIFValueResultChar_t>, typedef'ed to: C<char>.

=item MARPAESLIF_VALUE_TYPE_SHORT

Value type is C<marpaESLIFValueResultShort_t>, typedef'ed to: C<short>.

=item MARPAESLIF_VALUE_TYPE_INT

Value type is C<marpaESLIFValueResultInt_t>, typedef'ed to: C<int>.

=item MARPAESLIF_VALUE_TYPE_LONG

Value type is C<marpaESLIFValueResultLong_t>, typedef'ed to: C<long>.

=item MARPAESLIF_VALUE_TYPE_FLOAT

Value type is C<marpaESLIFValueResultFloat_t>, typedef'ed to: C<float>.

=item MARPAESLIF_VALUE_TYPE_DOUBLE

Value type is C<marpaESLIFValueResultDouble_t>, typedef'ed to: C<double>.

=item MARPAESLIF_VALUE_TYPE_PTR

Value type is C<marpaESLIFValueResultPtr_t>, typedef'ed to: C<struct { void *p; short shallowb; }>.

=item MARPAESLIF_VALUE_TYPE_ARRAY

Value type is C<marpaESLIFValueResultArray_t>, typedef'ed to: C<struct { void *p; short shallowb; size_t sizel; }>.

=item MARPAESLIF_VALUE_TYPE_BOOL

Value type is C<marpaESLIFValueResultBool_t>, typedef'ed to: C<enum>. Recommended values should be C<MARPAESLIFVALUERESULTBOOL_FALSE> (i.e. C<0>) or C<MARPAESLIFVALUERESULTBOOL_TRUE> (i.e. C<1>).

=item MARPAESLIF_VALUE_TYPE_STRING

Value type is C<marpaESLIFValueResultString_t>, typedef'ed to: C<struct { unsigned char *p; short shallowb; size_t sizel; char *encodingasciis; }>. C<p> and C<encodingasciis> I<must> be set, even for an empty string.

=back

A Value result is of type C<marpaESLIFValueResult_t> with more meta data:

  typedef short (*marpaESLIFRepresentation_t)(void *userDatavp,
                                              marpaESLIFValueResult_t *marpaESLIFValueResultp,
                                              char **inputcpp,
                                              size_t *inputlp);
  typedef struct marpaESLIFValueResult {
    void                      *contextp;          /* Free value meaningful only to the user */
    marpaESLIFRepresentation_t representationp;   /* How a user-land alternative is represented if it was in the input */
    marpaESLIFValueType_t      type;              /* Type for tagging the following union */
    union {
      marpaESLIFValueResultChar_t   c;            /* Value is a char */
      marpaESLIFValueResultShort_t  b;            /* Value is a short */
      marpaESLIFValueResultInt_t    i;            /* Value is an int */
      marpaESLIFValueResultLong_t   l;            /* Value is a long */
      marpaESLIFValueResultFloat_t  f;            /* Value is a float */
      marpaESLIFValueResultDouble_t d;            /* Value is a double */
      marpaESLIFValueResultPtr_t    p;            /* Value is a pointer */
      marpaESLIFValueResultArray_t  a;            /* Value is an array */
      marpaESLIFValueResultBool_t   y;            /* Value is a boolean */
      marpaESLIFValueResultString_t s;            /* Value is a string */
    } u;
  } marpaESLIFValueResult_t;

which means:

=over

=item contextp

This can be anything that is meaningul for the end-user. It must be different than C<NULL>, reserved to the marpaESLIF engine.

=item representationp

Associated representation in terms of input: this has an immediate impact on the C<::concat> and C<::convert[ENCODING]> actions:

  A ::= B C action => ::concat
  D ::= E F action => ::convert[ENCODING]

where C<::concat> is a binary concatenation, and C<::convert[ENCODING]> is a string conversion:

=over

=item

Representation callback exists: The binary content of the representation is taken as-is.

=item

No representation callback: The following default rules apply:

  |-------------------------------------------------------------------------------|
  | Value type                    | ::concat              | ::convert[ENCODING]   |
  |-------------------------------------------------------------------------------|
  | undefined                     | N/A                   | N/A                   |
  | marpaESLIFValueResultChar_t   | binary value          | formatted as %c       |
  | marpaESLIFValueResultShort_t  | binary value          | formatted as %d       |
  | marpaESLIFValueResultInt_t    | binary value          | formatted as %d       |
  | marpaESLIFValueResultLong_t   | binary value          | formatted as %ld      |
  | marpaESLIFValueResultFloat_t  | binary value          | formatted as %f (1)   |
  | marpaESLIFValueResultDouble_t | binary value          | formatted as %f (2)   |
  | marpaESLIFValueResultPtr_t    | u.p.p, size void*     | formatted as %p       |
  | marpaESLIFValueResultArray_t  | u.a.p, size u.a.sizel | u.a.p, size u.a.sizel |
  | marpaESLIFValueResultBool_t   | binary value          | formatted as %d       |
  | marpaESLIFValueResultString_t | u.s.p, size u.s.sizel | %s in ENCODING (3)    |
  |-------------------------------------------------------------------------------|

=over

=item (1) Float

Best effort formatting, using a string format that takes into account C's C<FLT_DIG> constant if any.

=item (2) Double

Best effort formatting, using a string format that takes into account C's C<DBL_DIG> constant if any.

=item (3) String

String transcoding, result is appended as if it was a binary concat.

=back

=back

=item type

This is the type itself, and has an impact on the C's C<union> that follows. Please note that:

=over

=item sizel

Some value type are containers, and C<sizel> gives the size in byte unit.

=item shallowb

This has an impact on internal value stack manipulation: everytime ESLIF tries to set a value, it is looking if this is going to replace something at the same stack indice. If the value to be replaced as this stack indice is not shallowed, free callback is called.

=back

=back

=head2 ESLIFRecognizer

One of the most important thing to understand is the notion of I<lexeme>: a I<lexeme> is a I<meta symbol> referencing another I<meta symbol> in another grammar. As such, it is a I<terminal> from the grammar point of view.

Internally, marpaESLIF have two terminal implementations:

=over

=item explicit terminal

These are terminals defined explicitely in the grammar as strings, character classes or regular expressions. These terminals have no name, and will be handled automatically by the recognizer during a scanning phase.

=item meta symbol

These are symbols that have no LHS counterpart in the current grammar, thus must be known to another grammar. We call them lexemes, and the other grammar is used as a I<lexing grammar>, totqlly managed by ESLIF, I<as if> this was an explicit terminal.

=back

This mean that if the end-user want to have control on the parsing, he <must> make sure that he will declare as a lexeme any part of the grammar on which he migh want to have some influence.

The subtility, so, is in the declaration of terminals. For instance, rules like this:

  <sequence rule> ::= <something>* separator => [\s]+
  <something>     ::= /[a-z]+/
  <something>     ::= 'X'

aren't declaring any lexeme: both C<[\s]+>, C</[a-z]+/> and C<'X'> are I<explicit> terminals in the same grammar level. There is no associated name, and the user will not be able to say "I want to push an alternative whose content is C<'X'> myself". On the other hand:

  <sequence rule> ::= <something>* separator => my_separator
  <something>     ::= /[a-z]+/
  <something>     ::= my_string

  my_separator      ~ [\s]+
  my_string         ~ 'X'

declares the symbols C<my_separator> and C<my_string> as lexemes: they are not in any LHS of the grammar at level 0 (the one with C<::=> declarations), they refer to a I<grammar used as lexer> that is at level 1 (the one with C<~> declarations). The user will be able to push himself alternatives using the symbol names C<my_separator> and C<my_string>. Taking the example of the C<'X'> string, the user have the freedom to push I<something else> but C<'X'>, because he took over the lexing phase. The only important thing from the top grammar point of view, is that the I<terminal> whose name is C<my_string> is an accepted alternative. Still, the end-user will not be able to push an alternative that would correspond to the expression C</[a-z]+/> at the C<something> location.

Since when a user push alternative himself lexing is bypassed, this mean that the I<representation> of this alternative is also totally under the user's control. Indeed, nothing prevent the user to push the alternative named C<my_string> and say its representation is something else but C<X>. This is the purpose of the C<marpaESLIFValueResult> structure: it is describing what ESLIF is calling a I<result>, and makes a clear distinction between a result and its representation.

Being able to affect the parse tree is only possible anywhen the recognizer holds on, i.e. anywhen there is an I<event>.

At any location in the grammar, possible alternatives can be of the two major types: I<explicit terminals> and lexemes (i.e. a I<meta symbol> refering another grammar). If the two types are present, and if at least one I<explicit terminal> matches, then the longests I<explicit terminal> will have absolute precedence over any lexeme. In other terms, I<explicit terminals> have an implicit absolute priority when they appear directly in a rule definition.

=head3 C<marpaESLIFRecognizer_newp>

  typedef short (*marpaESLIFReader_t)(void    *userDatavp,
                                      char   **inputcpp,
                                      size_t  *inputlp,
                                      short   *eofbp,
                                      short   *characterStreambp,
                                      char   **encodingsp,
                                      size_t  *encodinglp);
  /* Recognizer callback definitions */

  /* if-action callback: received a lexeme and return a boolean */
  typedef short (*marpaESLIFRecognizerIfCallback_t)(void *userDatavp,
                                                    marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                    marpaESLIFValueResult_t *marpaESLIFValueResultLexemep,
                                                    marpaESLIFValueResultBool_t *marpaESLIFValueResultBoolp);
  /* if-action callback resolver */
  typedef marpaESLIFRecognizerIfCallback_t (*marpaESLIFRecognizerIfActionResolver_t)(void *userDatavp,
                                                                                     marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                                                     char *actions);

  /* event-action callback: received an array of marpaESLIFEvent_t and return a boolean */
  typedef short (*marpaESLIFRecognizerEventCallback_t)(void *userDatavp,
                                                       marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                       marpaESLIFEvent_t *eventArrayp,
                                                       size_t eventArrayl,
                                                       marpaESLIFValueResultBool_t *marpaESLIFValueResultBoolp);
  /* event-action callback resolver */
  typedef marpaESLIFRecognizerEventCallback_t (*marpaESLIFRecognizerEventActionResolver_t)(void *userDatavp,
                                                                                           marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                                                           char *actions);

  /* regex-action callback: received a hash and return an integer */
  typedef short (*marpaESLIFRecognizerRegexCallback_t)(void *userDatavp,
                                                       marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                       marpaESLIFValueResult_t *marpaESLIFCalloutBlockp,
                                                       marpaESLIFValueResultInt_t *marpaESLIFValueResultOutp);
  /* regex-action callback resolver */
  typedef marpaESLIFRecognizerRegexCallback_t (*marpaESLIFRecognizerRegexActionResolver_t)(void *userDatavp,
                                                                                           marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                                                           char *actions);

  /* End-user recognizer importer facility */
  typedef short (*marpaESLIFRecognizerImport_t)(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                void *userDatavp,
                                                marpaESLIFValueResult_t *marpaESLIFValueResultp);

  typedef struct marpaESLIFRecognizerOption {
    void                *userDatavp;                  /* User specific context */
    marpaESLIFReader_t   readerCallbackp;             /* Reader callback */
    short                disableThresholdb;           /* Disable threshold warning.  Recommended: 0 */
    short                exhaustedb;                  /* Exhaustion event.           Recommended: 0 */
    short                newlineb;                    /* Count line/column numbers.  Recommended: 0 */
    short                trackb;                      /* Absolute position tracking. Recommended: 0 */
    size_t               bufsizl;                     /* Minimum stream buffer size. Recommended: 0 */
    /* Excess number of bytes, in % of bufsizl, where stream buffer size is reduced */
    unsigned int         buftriggerperci;             /*                             Recommended: 50 */
    /* Policy of minimum of bytes for increase, in % of current allocated size, when */
    /*  stream buffer size augment policy in % */
    unsigned int         bufaddperci;                 /*                             Recommended: 50 */
    marpaESLIFRecognizerIfActionResolver_t ifActionResolverp; /* symbol if action resolver. */
    marpaESLIFRecognizerEventActionResolver_t eventActionResolverp; /* Will return the function doing the wanted event action */
    marpaESLIFRecognizerRegexActionResolver_t regexActionResolverp; /* Will return the function doing the wanted regex callout action */
    marpaESLIFRecognizerImport_t              importerp;           /* Will ask end-user to import a marpaESLIFValueResult */
  } marpaESLIFRecognizerOption_t;

  marpaESLIFRecognizer_t *marpaESLIFRecognizer_newp(marpaESLIFGrammar_t          *marpaESLIFGrammarp,
                                                    marpaESLIFRecognizerOption_t *marpaESLIFRecognizerOptionp);

Creates a recognizer out of a C<marpaESLIFGrammarp> grammar instance.

The C<marpaESLIFReader_t> defines the prototype of a reader, referenced in the required parameter C<marpaESLIFRecognizerOptionp>. Its arguments are:

=over

=item C<userDatavp>

User opaque pointer, set in C<marpaESLIFRecognizerOptionp> and propagated as-is to the reader. There is no default value.

=item C<inputcpp>

The place where the user will set the pointer of the next available buffer. Default is C<NULL>.

=item C<inputlp>

The place where the user will set the number of bytes of the next available buffer. Default is C<0>.

=item C<eofbp>

The place where the user will set a flag saying this the end of data. Default is a false value.

=item C<characterStreambp>

The place where the user will set a flag saying this buffer I<must> be a stream of characters. Default is a false value.

=item C<encodingsp>

The place where the user will give a pointer to a buffer containing encoding information, in ASCII encoding. Default is C<NULL>.

=item C<encodinglp>

The place where the user will give a size of the buffer starting at C<*encodingsp>. Default is C<0>.

=back

Mixing binary and character streams is possible but only at the chunk level, where a chunk is the data buffer returned by the reader callback. It is up the user to be able to determine the boundaries. Here is how the character stream flag and encoding information is used by marpaESLIF at the return of the reader callback:

=over

=item 1 - User say this is a character stream

=over

=item A - Previous read was also a character streams

=over

=item a - User gave encoding (C<*encodingsp> is not C<NULL>)

If previous encoding is different, it is flushed and a new one is starting. Else previous encoding continue, this more will support incomplete character from the previous chunk.

=item b - User gave no encoding (C<*encodingsp> is C<NULL>)

It is assumed that previous encoding continue

=back

=item B - Previous read was not a stream of characters (or there was no previous read)

If user gave encoding information it is used, else encoding is guessed.

=back

=item 2 - User say this is not a character stream

=over

=item A - Previous read was a character stream

It is flushed, and binary data is appended as-is.

=item B - Previous read was not a character stream (or there was no previous read)

Binary data is appended as-is.

=back

=back

I<If> the grammar requires UTF-8 understanding of the buffer (either by using characters with code points greater than C<0xFF> in terminals, or explicitely setting the C<c> modifier to regular expressions - all of that meaning that PCRE2 expressions have the PCRE2_UTF flag), and C<If> the chunk of data was not declared as a character stream: it is assumed that it is in UTF-8 encoding. PCRE2 will check that and yell if it does not contain only valid UTF-8 characters.

The parameter C<marpaESLIFRecognizerOptionp> is a pointer to a C<marpaESLIFRecognizerOption_t> structure, where:

=over

=item C<userDatavp>

User context, propagated as-is to reader callback.

=item C<readerCallbackp>

Pointer to the reader callback. If C<NULL>, the stream will be considered complete (i.e. it reached end-of-file) at the very beginning.

=item C<disableThresholdb>

Disable treshold warning generated by L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html>. Recommended value is a false value, because when such warning arises, it usually indicate some problem with the grammar.

=item C<exhaustedb>

Support of exhaustion event. Recommended value is a false value, because the most common usage of parsing data is to parse the full buffer up to its end of data. Nevertheless is is quite easy to find applications that support the exhaustion, for example parsing of binary structures that contain sub-structures, and so on. Setting this flag is also the I<only> way to have the C<marpaESLIFGrammar_parseb> method successful even if not all data is consumed.

=item C<newlineb>

Support of newline count. This is used when the parser fails to produce ab accurate report with line and number information. Works at the granularity of data chunk, and is meaningless if data chunk is not declared as a character stream. Any Unicode line ending sequence is considered.

=item C<trackb>

Support of absolute position tracking. The recognizer have to track absolute position to successfuly process the C<marpaESLIFRecognizer_last_completedb()> method (see below). Nevertheless, maintaining such information has a cost and is not fully reliable because there is no attempt to check for an eventual turnaround of the associated internal variables. You should put this option to a true value only if you plan to use C<marpaESLIFRecognizer_last_completedb()>.

=item C<bufsizl>

Default number of bytes of the internal buffer in marpaESLIF, in which I<all> data is stored and appended. If C<0>, the value used when compiling marpaESLIF library is used, itself defaulting to 1Mb. Recommended value is C<0>.

=item C<buftriggerperci>

In order to prevent internal buffer to grow indefinitely, C<buftriggerperci> is the percentage of C<bufsizl> that give a trigger on the number of unused bytes at which the internal buffer is reduced to its initial size C<bufsizl>. Recommended value is C<50>.

=item C<bufaddperci>

To prevent too many memory allocations, when marpaESLIF need to increase its internal buffer, it will do so by requesting C<bufaddperci> percent of current allocated size more bytes. Recommended value: C<50>.

=item C<ifActionResolverp>

If a lexeme or a terminal is a candidate for automatic parsing (I<scan> or I<parse> modes), this callback must not be C<NULL> and return a function pointer. The later will be be called with a C<marpaESLIFValueResultLexemep> argument that is guaranteed to be of type C<ARRAY>, and must return in C<marpaESLIFValueResultBoolp>, guaranteed to not be C<NULL>, a boolean value saying of the lexeme or terminal can be taken in account in the parse tree.

The function will return a true value in case of success, a false value otherwise.

=back

This method returns a recognizer pointer in case of success, C<NULL> in case of failure.

=head3 C<marpaESLIFRecognizer_newFromp>

  marpaESLIFRecognizer_t *marpaESLIFRecognizer_newFromp(marpaESLIFGrammar_t    *marpaESLIFGrammarp,
                                                        marpaESLIFRecognizer_t *marpaESLIFRecognizerSharedp);

Creates a recognizer out of a C<marpaESLIFGrammarp> grammar instance, that is using explicitly the I<same> settings as C<marpaESLIFRecognizerSharedp> and shares the later's stream.

From there, any update to the new recognizer's stream or C<marpaESLIFRecognizerSharedp>'s stream are synchronous and shared. Running the new recognizer and the shared recognizer in parallel is not allowed.

The input stream callback will use C<marpaESLIFRecognizerSharedp> settings.

It is the application responsibility to make sure that the lifetime of C<marpaESLIFRecognizerSharedp> is <greater> than newly created recognizer instance.
This method returns a recognizer pointer in case of success, C<NULL> in case of failure.

=head3 C<marpaESLIFRecognizer_set_exhausted_flagb>

  short marpaESLIFRecognizer_set_exhausted_flagb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                 short                   exhaustedb);

The only recognizer option that can be changed at runtime is the C<exhaustedb> flag. The later is important when the recognizer cannot accept any new data (i.e. parse is exhausted) but unprocessed data remains: if C<exhaustedb> is a false value, then an error is raised.

This method returns a true value in case of success, a false value otherwise.

=head3 C<marpaESLIFRecognizer_shareb>

  short marpaESLIFRecognizer_shareb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                    marpaESLIFRecognizer_t *marpaESLIFRecognizerSharedp);

A recognizer can be instructed to share the stream with another C<marpaESLIFRecognizerSharedp> at any time. When C<marpaESLIFRecognizerSharedp> is C<NULL>, sharing is stopped. Running the new recognizer and the shared recognizer in parallel is not allowed.

It is the application responsibility to make sure that the lifetime of C<marpaESLIFRecognizerSharedp> is <greater> than C<marpaESLIFRecognizerp>.

The input stream callback is still using C<marpaESLIFRecognizerp>, but streaming positions of both C<marpaESLIFRecognizerp> are affected.

This method returns a true value in case of success, a false value otherwise.

=head3 C<marpaESLIFRecognizer_optionp>

  marpaESLIFRecognizerOption_t *marpaESLIFRecognizer_optionp(marpaESLIFRecognizer_t *marpaESLIFRecognizerp);

Returns the options used to create the C<marpaESLIFRecognizerp> instance, or C<NULL> if failure. The returned pointer must I<never> be freed.

=head3 C<marpaESLIFRecognizer_scanb>

  short marpaESLIFRecognizer_scanb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                   short initialEventsb,
                                   short *isCanContinuebp,
                                   short *isExhaustedbp);

Start a scanless parsing using the C<marpaESLIFRecognizerp> instance. Only one such call can be done in the whole lifetime of a recognizer. Parameters are:

=over

=item initialEventsb

Traditionnally initial events are not of use and are skipped. When true, this flag enable such events.

=item isCanContinuebp

The scanning will pause as soon as there is an event or an error. When not C<NULL>, the value pointed by C<isCanContinuebp> say that if scanning can continue if it is a true value.

=item isExhaustedbp

If not C<NULL>, this value pointed by C<isExhaustedbp> will say if the parse is exhausted, regardless if there is an exhaustion event or not.

=back

A typical usage of the C<marpaESLIFRecognizer_scanb> method is:

  short isCanContinuebp;
  short exhaustedb;

  if (! marpaESLIFRecognizer_scanb(marpaESLIFRecognizerp,
                                   0 /* initialEventsb */,
                                   &isCanContinuebp,
                                   &exhaustedb)) {
    goto error_processing;
  }
  while (isCanContinuebp) {
    /* See below for the events, pause and resume methods */
  }

This method returns a true value on success, a false value on failure, and can generate grammar and pause events.

=head3 C<marpaESLIFRecognizer_resumeb>

  short marpaESLIFRecognizer_resumeb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                     size_t deltaLengthl,
                                     short *isCanContinuebp,
                                     short *isExhaustedbp);

Resume the scanning. All parameters have the same meaning as for C<marpaESLIFRecognizer_scanb>, with an additional C<deltaLengthl> that say to the recognizer to skip this given number of byte before going on. A typical usage is:

  short isCanContinuebp;
  short exhaustedb;

  if (! marpaESLIFRecognizer_scanb(marpaESLIFRecognizerp,
                                   0 /* initialEventsb */,
                                   &isCanContinuebp,
                                   &exhaustedb)) {
    goto error_processing;
  }
  while (isCanContinuebp) {
    /* See below for the events and pause */
    /* ... */
    /* Resume */
    if (! marpaESLIFRecognizer_resumeb(marpaESLIFRecognizerp,
                                       0,
                                       &isCanContinuebp,
                                       &exhaustedb)) {
      goto error_processing;
    }
  }

This method can generate grammar and pause events.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_alternativeb>

  typedef struct marpaESLIFAlternative {
    char                   *lexemes;        /* Lexeme name */
    marpaESLIFValueResult_t value;          /* Value */
    size_t                  grammarLengthl; /* Length in the grammar (1 == token-stream model) */
  } marpaESLIFAlternative_t;

  short marpaESLIFRecognizer_lexeme_alternativeb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                 marpaESLIFAlternative_t *marpaESLIFAlternativep);

It is possible to inject arbitrarty lexemes outside of the internal scanner. Such external lexemes are described using a C<marpaESLIFAlternative_t> structure, containing:

=over

=item lexemes

The lexeme name as per the grammar. Must be different than C<NULL>.

=item value

A structure describing the value. Please refer to the "ESLIF Value Result" section for explanation.

=item grammarLengthl

The number of grammar tokens taken by this alternative. A highly recommended value is C<1>, which correspond to the tradional "token-stream" model. This number must be greater than zero, and putting a value greater than C<1>, will make the parser believe that your alternative has consumed as many terminals.

=back

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_completeb>

  short marpaESLIFRecognizer_lexeme_completeb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                              size_t lengthl);

Say to the recognizer pointed C<marpaESLIFRecognizerp> by that the current set of lexeme alternatives is complete, and that the stream should advance by C<length> bytes, where bytes is really the number of bytes in the internal recognizer buffer, i.e. an UTF-8 sequence of code points in case of a character-oriented stream. The reader callback may be called if necessary, in case the caller say to advance by more bytes than what is currently available. It is an error to specify more bytes than the recognizer can get (and eventually transform, in case of character-stream oriented buffer) from the reader. A a value of C<0> for the length is legal.

If a I<lexeme after> event is triggered, C<marpaESLIFRecognizer_lexeme_last_pauseb> will show as many bytes as C<lengthl>. And because it is guaranteed that C<marpaESLIFRecognizer_lexeme_last_pauseb> returns a pointer to NUL-terminated buffer, the extreme case is that last pause can be an empty string "" when the alternative has been pushed using a user-defined value.

This method can generate grammar and pause events.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_readb>

  short marpaESLIFRecognizer_lexeme_readb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          marpaESLIFAlternative_t *marpaESLIFAlternativep);
                                          size_t lengthl);

A short-hand version of lexeme management that is pushing an alternative and do completion in one call.

This method can generate grammar and pause events.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_tryb>

  short marpaESLIFRecognizer_lexeme_tryb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                         char *lexemes,
                                         short *matchbp);

Try to match the lexeme with name C<lexemes> that must be non-C<NULL> against the input seen by the recognizer. Returns in C<matchbp>, when not C<NULL>, a true value if there is a match, a false value otherwise. This method generates no event.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_discard_tryb>

  short marpaESLIFRecognizer_discard_tryb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          short *matchbp);

Try to match the :discard rule against the input seen by the recognizer. Returns in C<matchbp>, when not C<NULL>, a true value if there is a match, a false value otherwise. This method generates no event.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_lexeme_expectedb>

  short marpaESLIFRecognizer_lexeme_expectedb(marpaESLIFRecognizer_t   *marpaESLIFRecognizerp,
                                              size_t                   *nLexemelp,
                                              char                   ***lexemesArraypp);

For the current recognizer C<marpaESLIFRecognizerp>, get the list of I<lexemes> expected. C<*nLexemelp>, if not C<NULL>, is filled with the number of expected lexemes, and C<*lexemesArraypp>, if not C<NULL>, will contain the array of NUL-terminated ASCII symbol names.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_isEofb>

  short marpaESLIFRecognizer_eofb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp, short *eofbp);

Returns in the value pointed by C<eofbp> the current EOF state, when it is not C<NULL>. Take care, it jus says that the reader callback said that there is nothing more to read, this do not mean that the parser reached this point. To have the equivalent of "end of file is reached" parser state, please refer to the method C<marpaESLIFRecognizer_stream_isEndb>.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_isExhaustedb>

  short marpaESLIFRecognizer_isExhaustedb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp, short *isExhaustedbp);

Returns in the value pointed by C<isExhaustedbp> the current grammar exhaustion state, when it is not C<NULL>. This method can be called at any time. It does not conflict with the C<isExhaustedbp> parameter in C<marpaESLIFGrammar_parseb()>, C<marpaESLIFGrammar_parse_by_levelb()>, , C<marpaESLIFGrammar_scan()> or C<marpaESLIFGrammar_resumeb()>, that provide the same parameter for convienence.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_isCanContinueb>

  short marpaESLIFRecognizer_isCanContinueb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp, short *isCanContinueb);

Returns in the value pointed by C<isCanContinueb> the current recognizer continuation flag state, when it is not C<NULL>. This method can be called at any time. It does not conflict with the C<isExhaustedbp> parameter in C<marpaESLIFGrammar_parseb()>, C<marpaESLIFGrammar_parse_by_levelb()>, , C<marpaESLIFGrammar_scan()> or C<marpaESLIFGrammar_resumeb()>, that provide the same parameter for convienence.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_event_onoffb>

  typedef enum marpaESLIFEventType {
    MARPAESLIF_EVENTTYPE_NONE       = 0x00,
    MARPAESLIF_EVENTTYPE_COMPLETED  = 0x01, /* Grammar event */
    MARPAESLIF_EVENTTYPE_NULLED     = 0x02, /* Grammar event */
    MARPAESLIF_EVENTTYPE_PREDICTED  = 0x04, /* Grammar event */
    MARPAESLIF_EVENTTYPE_BEFORE     = 0x08, /* Just before lexeme is commited */
    MARPAESLIF_EVENTTYPE_AFTER      = 0x10, /* Just after lexeme is commited */
    MARPAESLIF_EVENTTYPE_EXHAUSTED  = 0x20, /* Exhaustion */
    MARPAESLIF_EVENTTYPE_DISCARD    = 0x40  /* Discard */
  } marpaESLIFEventType_t;

  short marpaESLIFRecognizer_event_onoffb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          char                   *symbols,
                                          marpaESLIFEventType_t   eventSeti,
                                          short                   onoffb);

For the recognizer pointed by C<marpaESLIFRecognizerp>, switches on or off the event types C<eventSeti> (which is a bit mask of event type), depending of C<onoffb> value, at symbol with name C<symbols> (a NUL terminated ASCII string) of current grammar. Setting on or off a non-existing event is a no-op. There are eight type of events, described with the enum C<marpaESLIFEventType_t>:

=over

=item C<MARPAESLIF_EVENTTYPE_NONE>

No event -;

=item MARPAESLIF_EVENTTYPE_COMPLETED

Completion event. This can happen only for meta symbol names. In the grammar this is declared with:

  event start$ = completed symbolname

=item MARPAESLIF_EVENTTYPE_NULLED

Nulled event. This can happen only for meta symbol names. In the grammar this is declared with:

  event start$ = nulled symbolname

=item MARPAESLIF_EVENTTYPE_PREDICTED

Prediction event. This can happen only for meta symbol names. In the grammar this is declared with:

  event start$ = predicted symbolname

=item MARPAESLIF_EVENTTYPE_BEFORE

I<Lexeme before> event. This can happen only for lexemes that are predicted by the scanning. In the grammar this is declared with:

  :lexeme ::= lexemename pause => before event => eventname

=item MARPAESLIF_EVENTTYPE_AFTER

I<Lexeme before> event. This can happen only for lexemes after they are pushed as alternatives by the scanning. In the grammar this is declared with:

  :lexeme ::= lexemename pause => after event => eventname

=item MARPAESLIF_EVENTTYPE_EXHAUSTED

Exhaustion event. It has no name, and is possible only if the recognizer is instanciated with the C<exhaustedb> flag being a true value in the C<marpaESLIFRecognizerOption_t> structure.

=item MARPAESLIF_EVENTTYPE_DISCARD

Discard event. This can happen only for C<:discard> rules, and happen everytime a C<:discard> rule is completed at the top-level grammar. In the grammar this is declared with:

  :discard ::= whitespace event => discard_whitespace

=back

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_eventb>

  typedef struct marpaESLIFEvent {
    marpaESLIFEventType_t type;
    char                 *symbols; /* Symbol name, NULL if exhausted event, ':discard' if discard event */
    char                 *events;  /* Event name, always NULL if exhaustion eent */
  } marpaESLIFEvent_t;

  short marpaESLIFRecognizer_eventb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                    size_t                  *eventArraylp,
                                    marpaESLIFEvent_t      **eventArraypp);

Retreive the current list of events within the recognizer pointed by C<marpaESLIFRecognizerp>, putting in the value pointed by C<eventArraylp>, if it is not NULL, the number of event, and in the value pointed by C<eventArraypp>, if it not NULL, the list of these events. An event is always a structure of type C<marpaESLIFEvent_t> containing:

=over

=item type

The type of event. C.f. upper section for a description of C<marpaESLIFRecognizer_t> type.

=item symbols

The name of the symbol that triggered the event. Always a NUL-terminated ASCII string, except for exhaustion where it is C<NULL>.

=item events

The name of the event. Always a NUL-terminated ASCII string, except for exhaustion where it is C<NULL>.

=back

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_progressLogb>

  short marpaESLIFRecognizer_progressLogb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          int                     starti,
                                          int                     endi,
                                          genericLoggerLevel_t    logleveli);

Send to the logger configured at the marpaESLIF instanciation step, the current progress of parsing of the C<marpaESLIFRecognizerp> recognizer instance. Logging is do at level C<logleveli> (c.f. L<genericLogger|https://github.com/jddurand/c-genericLogger> documentation), and from C<starti> to C<endi> indices. The C<starti> and C<endi> indices are Earleme Set Ids, and obey the Perl language convention, i.e. a negative indice means it far back from the end. The format of the strings generated is totally under the L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper> library. This method should be used when the end user want to have a progress report during valuation, c.f. the C<marpaESLIFValue_value_startb> and C<marpaESLIFValue_value_lengthb> methods.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_inputb>

  short marpaESLIFRecognizer_inputb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                    char                   **inputsp,
                                    size_t                  *inputlp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns the current internal buffer state, i.e.:

=over

=item inputsp

If not C<NULL>, will contain the current input internal buffer pointer.

=item inputlp

If not C<NULL>, will contain the current input internal buffer length.

=back

These pointers are intentionaly not having a I<const> keyword, though it is obvious that any attempt to modify C<*inputsp> or C<*inputlp> is likely to make the process crash. The internal buffer may I<not> correspond to what the callback returned in case there is character conversion: in this case the internal buffer contains UTF-8 character sequences.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_locationb>

  short marpaESLIFRecognizer_locationb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                       size_t *linelp,
                                       size_t *columnlp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns the current line and number, i.e.:

=over

=item linelp

If not C<NULL>, will contain the current absolute line number.

=item columnlp

If not C<NULL>, will contain the current absolute column number.

=back

Please note that this is in effect only if the recognizer option have a true value for C<newlineb>, and for character chunks.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_last_pauseb>

  short marpaESLIFRecognizer_lexeme_last_pauseb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                                char                    *lexemes,
                                                char                   **pausesp,
                                                size_t                  *pauselp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns a pointer to the last portion of input stream that generated a I<lexeme pause> event for lexeme C<lexemes> in the value pointed by C<pausesp> if it is not NULL, and the length in the value pointed by C<pauselp> if it is not NULL. For convenience if the last pause is not NULL, the buffer holding the pause information is always NUL-terminated, even if the C<\0> NUL character is I<not> in the returned length. In case of user-defined alternatives, the empty string "" is returned in C<pausesp>.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_lexeme_last_tryb>

  short marpaESLIFRecognizer_lexeme_last_tryb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                              char                    *lexemes,
                                              char                   **trysp,
                                              size_t                  *trylp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns a pointer to the last portion of input stream into the value pointed by C<trysp>, when it is non-C<NULL>, and corresponding length in the value pointed by C<trylp> when it is is non-C<NULL>, of the last successful try for lexeme C<lexemes>, via a call to C<marpaESLIFRecognizer_lexeme_tryb>. If C<*trysp> is non-NULL, it is guaranteed that C<*trylp> is greater than zero, and the block of memory is NUL-terminated, even if the additional NUL byte will not be included into C<trylp>.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_discard_last_tryb>

  short marpaESLIFRecognizer_discard_last_tryb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                               char                   **trysp,
                                               size_t                  *trylp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns a pointer to the last portion of input stream into the value pointed by C<trysp>, when it is non-C<NULL>, and corresponding length in the value pointed by C<trylp> when it is is non-C<NULL>, of the last successful discard try, via a call to C<marpaESLIFRecognizer_discard_tryb>. If C<*trysp> is non-NULL, it is guaranteed that C<*trylp> is greater than zero, and the block of memory is NUL-terminated, even if the additional NUL byte will not be included into C<trylp>.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_discard_lastb>

  short marpaESLIFRecognizer_discard_lastb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                           char                   **lastsp,
                                           size_t                  *lastlp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns a pointer to the last portion of input stream into the value pointed by C<lastsp>, when it is non-C<NULL>, and corresponding length in the value pointed by C<lastsp> when it is is non-C<NULL>, of the last successful discard. If C<*lastsp> is non-NULL, it is guaranteed that C<*lastlp> is greater than zero, and the block of memory is NUL-terminated, even if the additional NUL byte will not be included into C<lastlp>.

For performance reasons, last discard data is available only if the recognizer interface has a true value for C<trackb>, I<and> if there is a discard event for the C<:discard> rule that matched.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_readb>

  short marpaESLIFRecognizer_readb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                   char                   **inputsp,
                                   size_t                  *inputlp);

Forces a call to the reader callback. All parameters have the semantic as in the method C<marpaESLIFRecognizer_inputb>.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_last_completedb>

  short marpaESLIFRecognizer_last_completedb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                             char                    *names,
                                             char                   **offsetpp,
                                             size_t                  *lengthlp);

Convenience method that, for the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns the I<absolute offset> since the beginning of the scanning in the value pointed by C<offsetpp> if it not C<NULL>, and the length in the value pointed by C<lengthlp> if it is not C<NULL>, of the last completion for symbol C<names>, that must not be C<NULL>. This I<absolute offset> is computed without consideration of any turnaround, thus if the amount of data that has been scanned is larger what a C<char *> can adress, the offset value will not be reliable. Same remark for the length.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_hook_discardb>

  marpaESLIFRecognizer_hook_discardb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                     short discardOnOffb);

Hook the recognizer to enable or disable the use of C<:discard> if it exists. Default mode is on. This is a I<permanent> setting.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_freev>

  void marpaESLIFRecognizer_freev(marpaESLIFRecognizer_t *marpaESLIFRecognizerp);

The destructor of a marpaESLIFRecognizer instance C<marpaESLIFRecognizerp> instance. No-op if C<marpaESLIFRecognizerp> is C<NULL>.

=head3 C<marpaESLIFRecognizer_stream_isBeginb>

  short marpaESLIFRecognizer_stream_isBeginb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp, short *beginbp);

Returns in the value pointed by C<beginbp>, if not C<NULL>, a boolean saying if the parser has started to read data.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_stream_isNewlineb>

  short marpaESLIFRecognizer_stream_isNewlineb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp, short *newlinebp);

Returns in the value pointed by C<newlinebp>, if not C<NULL>, a boolean saying if the parser has matched a newline. Take care, newline counting is done only when:

=over

=item the recognizer has been instanciated with the C<newlineb> option set to a true value

=over

==item Note that if the grammar contains the pseudo-lexeme C<::newline>, anywhere, then C<newlineb> is automatically set to true, regardless of user's choice

=back

=item the current stream bunch of data is treated as a character buffer, or if last one terminal match used a regular expression that has the C<PCRE2_UTF> flag

=item current recognizer is the top-level recognizer

=back

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_stream_isEndb>

  short marpaESLIFRecognizer_stream_isEndb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp, short *endbp);

Returns in the value pointed by C<endbp>, if not C<NULL>, a boolean saying if the parser has reached and end of input, meaning that reader callback did set the C<eofb> flag I<and> that all remaining data has been consumed. Alike C<marpaESLIFRecognizer_stream_isNewlineb>, end of buffer flag is internally updated only by the top-level recognizer.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head2 ESLIFValue

At any point in the parsing lifetime it is possible to call for parse tree values. Traditionnaly this is happening when all data has been scanned, or when the parsing has exhausted.

=head3 C<marpaESLIFValue_newp>

  typedef short (*marpaESLIFValueRuleCallback_t)  (void              *userDatavp,
                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                   int                arg0i,
                                                   int                argni,
                                                   int                resulti,
                                                   short              nullableb);

  typedef short (*marpaESLIFValueSymbolCallback_t)(void              *userDatavp,
                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                   char              *bytep,
                                                   size_t             bytel,
                                                   int                resulti);

  typedef void  (*marpaESLIFValueFreeCallback_t)  (void              *userDatavp,
                                                   int                contexti,
                                                   void              *p,
                                                   size_t             sizel);

  typedef marpaESLIFValueRuleCallback_t   (*marpaESLIFValueRuleActionResolver_t)  (void              *userDatavp,
                                                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                                                   char              *actions);

  typedef marpaESLIFValueSymbolCallback_t (*marpaESLIFValueSymbolActionResolver_t)(void              *userDatavp,
                                                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                                                   char              *actions);

  /* End-user valuator importer facility */
  typedef short (*marpaESLIFRecognizerImport_t)(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                void *userDatavp,
                                                marpaESLIFValueResult_t *marpaESLIFValueResultp);

  typedef struct marpaESLIFValueOption {
    void                                 *userDatavp;            /* User specific context */
    marpaESLIFValueRuleActionResolver_t   ruleActionResolverp;   /* Returns pointer to rule action */
    marpaESLIFValueSymbolActionResolver_t symbolActionResolverp; /* Returns pointer to symbol action */
    marpaESLIFValueImport_t               importerp;             /* Will ask end-user to import a marpaESLIFValueResult */
    short                                 highRankOnlyb;         /* Recommended: 1 */
    short                                 orderByRankb;          /* Recommended: 1 */
    short                                 ambiguousb;            /* Recommended: 0 */
    short                                 nullb;                 /* Recommended: 0 */
    int                                   maxParsesi;            /* Recommended: 0 */
  } marpaESLIFValueOption_t;

  marpaESLIFValue_t *marpaESLIFValue_newp(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                          marpaESLIFValueOption_t *marpaESLIFValueOptionp);

where C<userDatavp> is a user opaque value, holding user specific context. Action resolvers are looked up later in this section. The other parameters are:

=over

=item highRankOnlyb

Actions can have a I<rank>, e.g.:

  my_rule ::= I J 'string terminal' rank => 2
  my_rule ::= K L 'string terminal' rank => 1

say that C<my_rule> have two alternatives, with different ranks.

I<If> the next parameter C<orderByRankb> is a true value, then only rule with highest rank will be taken into account. This is a nice nice way to have a grammar ambiguous by nature, though having a non-ambiguous parse tree value from it.

=item orderByRankb

Specify if the rank is to be used.

=item ambiguousb

Specify if parse tree valuation can be ambiguous. Application's choice -;

=item nullb

Allow a parse tree valuation to produce nothing. It is recommended to set this to a false value.

=item maxParsesi

In case of ambiguity, there can be a lot of parse tree valuation results. If greater than zero, C<maxParsesi> is a higher limit on such number.

=back

Valuation lifetime is on the top-level grammar and has two main entry points:

=over

=item Valuation of terminals

Terminals are what comes directly from the input stream. From grammar point of view, this correspond to string, character class, regular expressions, or lexemes.

=item Valuation of rules

Indeed, the valuation lifetime of something like e.g.:

  this_rule ::= 'string terminal'

is:

=over

=item 1 - Evaluate C<'string terminal'>

=item 2 - Evaluate C<this_rule>

=back

and nothing impose that the valuation result of C<my_rule> would be same as C<'string terminal'> valuation result.

The functions holding valuation results are totally unknown from marpaESLIF, which is always asking to user-space for a function pointer of the correct type, whenever needed. For that it is using I<action resolvers>. An action resolver is always called for a given I<action name> C<actions>, guaranteed to a NUL-terminated ASCII string. In other terms marpaESLIF will always call the actions resolver like this:

=over

=item For rules

  ruleActionp = ruleActionResolverp(userDatavp, marpaESLIFValuep, actions)

=item For symbols

  symbolActionp = symbolActionResolverp(userDatavp, marpaESLIFValuep, actions)

=back

and nothing impose the action resolvers to always return the same function pointer for a given NUL-terminated ASCII C<action> string.

The value result itself is also not under marpaESLIF control, though the later requires the user to manipulate a I<stack>, and to assign to every entry in the stack a I<value type>, and a I<value context>. So there is a notion of I<user stack>, which start at indice number C<0>, and whose length is determined by the parse tree value location. The context of every I<value> in the stack is nothing else but a free number different than zero that should describe what it is, and has a meaning only for the end-user. It is important to set a correct context when assigning values to the stack, because this is how the I<memory free> function pointer, another function leaving in user space, will know how to react. For example a rule like this:

  my_rule ::= I J 'string terminal' action => my_action

could be called with output stack indice C<0> and input stack indices C<0> for C<I>, C<1> for C<J>, and C<2> for C<K>. It is the end user that knows what it is all about, through the famous I<context>. Suppose that types of data would be a pointer (C<PTR> below) with context value C<0x12>, an integer (C<INT> below) with context value C<0x34>, and a short (C<SHORT> below) with context value C<0x56>, and that the end user decided that the result is a long with context C<0x78>, then a representation of the stack is:

  |---------------------------------------------------|
  |            | my_rule =    I    J 'string terminal'|
  |---------------------------------------------------|
  |Stack indice|       0 =    0    1                 2|
  |        Type|    LONG    PTR  INT             SHORT|
  |     Context|    0x78   0x12 0x34              0x56|
  |---------------------------------------------------|

You will note that:

=over

=item The context of the terminal is a short !?

The <'string terminal'> terminal is coming from input stream. There is I<no> associated symbol, and the function that manage symbols is covered by this grammar statement:

  :default ::= symbol-action => my_symbol_action

marpaESLIF called the symbol action resolver C<symbolActionResolverp> for action C<"my_symbol_action">, the later returning function pointer C<my_symbol_actionp>, and marpaESLIF called this function pointer like this:

  my_symbol_actionp(userDatavp, marpaESLIFValuep, p, l, 2)

where C<p> is a pointer to a copy of input stream C<'string terminal'>, of size C<l>, asking for the result to be pushed at stack indice number C<2>. It is the user that decided that it will put a short value at indice 2, with context C<0x56>.

=item You talk about value types and context in the stack, but B<how> can this be set?

marpaESLIF provide stack manipulation functions, and it is simply impossible for the end-user to manipulate the stack without using these functions. Stack itself is maintained inside marpaESLIF. Please see all C<marpaESLIFValue_stack_xxx> functions documented later.

=item Stack number indice C<0> is in I<both input and output> indices

This mean that, at any time, a stack indice can be replaced by another. This is a decision of the parse tree engine, based on rule definitions.

Suppose that valuation of rule C<my_rule>, there is already something at indice C<0> in the stack and it is a pointer!? marpaESLIF will I<automatically> call for I<memory free> action on this indice if the pointer is not shallowed, before replacing it by the C<my_rule> result. The I<free action> is set at the grammar level:

  :default ::= free-action => my_free_action

=back

Full history of our example rule C<my_rule> action is then:

=over

=item 1. Call the action resolver for C<"my_action">

The function call is equivalent to

  ruleActionResolverp(userDatavp, marpaESLIFValuep, "my_action")

We suppose that it returned a function pointer to C<my_actionp>, a function that exist in user-space.

=item 2. Call C<my_actionp>

The function call is

  my_actionp(userDatavp, marpaESLIFValuep, 0/* arg0i */, 2/* argni */, 0/* resulti */, 0/* nullableb */)

What is this C<nullableb> flag!? Well, it means what it means: sometimes a rule is nullable, for example the empty rule:

  nullableRule ::= action => my_action2;

or a sequence rule:

  nullableRule ::= item* action => my_action2

Then, and only in these cases, the C<nullableb> flag is a true value, C<arg0i> and C<argni> will be both C<-1>, e.g. (with C<my_action2p> being the rule resolver result for action C<"my_action2">):

  my_action2p(userDatavp, marpaESLIFValuep, -1/* arg0i */, -1/* argni */, 0/* resulti */, 1/* nullableb */)

Ok, so finally C<my_actionp> is called, and it decided to return a value of type I<long> and context C<0x78>.

=item 3. Put user data at stack indice C<0> and context C<0x78>

=back

Nothing differentiate symbol actions v.s. rule action except that there is no range of indices in input, only a single indice.

Returns C<NULL> is no valuation is possible at this stage, else return a non-C<NULL> value.

=item Final result

ESLIF never keeps in memory the I<final> result. Before freeing its internal stack, it will ask the user to do an import using C<importp> marpaESLIFValueResult's option, if set.

The goal of the transformer is to get into user's space a managable equivalent to an ESLIF value. Please refer to the L<marpaESLIF_BINDINGS> bindings documentation.

=back

=head3 C<marpaESLIFValue_recognizerp>

  marpaESLIFRecognizer_t *marpaESLIFValue_recognizerp(marpaESLIFValue_t *marpaESLIFValuep);

Returns the marpaESLIF's recognizer instance used to create the C<marpaESLIFValuep> instance.

=head3 C<marpaESLIFValue_optionp>

  marpaESLIFValueOption_t *marpaESLIFValue_optionp(marpaESLIFValue_t *marpaESLIFValuep);

Returns the options used to create the C<marpaESLIFValuep> instance, or C<NULL> if failure. The returned pointer must I<never> be freed.

=head3 C<marpaESLIFValue_valueb>

  short marpaESLIFValue_valueb(marpaESLIFValue_t       *marpaESLIFValuep,
                               marpaESLIFValueResult_t *marpaESLIFValueResultp);

Calls for parse tree valuation. Parameter C<marpaESLIFValueResultp> can be C<NULL>, meaning that the end-user is not interested by the value. Otherwise, this a pointer to a structure of type C<marpaESLIFValueResult_t> that will host the result. Technically, please note that a final parse tree valuation is <always> at stack indice number C<0>:

The return value of C<marpaESLIFValue_valueb> is always:

=over

=item 1 on success

=item 0 on end

=item -1 on failure

=back

I.e. a typical usage is:

  while (1) {
    short rcValueb = marpaESLIFValue_valueb(marpaESLIFValuep, NULL);
    if (rcValueb < 0) {
      goto err;
    } else if (rcValueb == 0) {
      break;
    }
  }

=head3 C<marpaESLIFValue_value_startb>

  short marpaESLIFValue_value_startb(marpaESLIFValue_t *marpaESLIFValuep, int *startip);

Taken directly from L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper> interface, this is returning the Start Earleme Set Ids of current valuation phase in the value pointed by C<startip>, if the later is not C<NULL>. This should be used to produce progress reports if wanted.

This method cannot be called outside a valuation callback. C.f. C<marpaESLIFValue_value_lengthb> for an example.

Returns a true value on success, else a false value.

=head3 C<marpaESLIFValue_value_lengthb>

  short marpaESLIFValue_value_lengthb(marpaESLIFValue_t *marpaESLIFValuep, int *lengthip);

Returns the number of Earleme Set Ids in the value pointed by C<lengthip>, if the later is not C<NULL>.

The length is greater than zero only when current Start Earleme Set Id is at a non-nullable symbol. This method cannot be called outside a valuation callback.

A typical usage example is:

  int starti;
  int lengthi;

  if (marpaESLIFValue_value_startb(marpaESLIFValuep, &starti) &&
      marpaESLIFValue_value_lengthb(marpaESLIFValuep, &lengthi)) {
      marpaESLIFRecognizer_progressLogb(marpaESLIFValue_recognizerp(marpaESLIFValuep),
                                        starti,
                                        /* lengthi is zero when this is a nullable symbol */
                                        (lengthi > 0) ? starti+lengthi-1 : starti,
                                        GENERICLOGGER_LOGLEVEL_ERROR);
    }

Returns a true value on success, else a false value.

=head3 C<marpaESLIFValue_contextb>

  short marpaESLIFValue_contextb(marpaESLIFValue_t  *marpaESLIFValuep,
                                 char              **symbolsp,
                                 int                *symbolip,
                                 char              **rulesp,
                                 int                *ruleip);

Puts in the value pointed by C<symbolsp> if it is not C<NULL>, the current symbol name if valuation occurs on a symbol, or in the value pointed by C<rulesp> if it is not C<NULL>, the current current rule name if valuation occurs on a rule. Idem for C<symbolip> and C<ruleip> concerning symbol Id and rule Id, respectively, where the value C<-1> is filled for cases that do not apply.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFValue_freev>

  void marpaESLIFValue_freev(marpaESLIFValue_t *marpaESLIFValuep);

The destructor of a marpaESLIFValue instance C<marpaESLIFValuep> instance. No-op if C<marpaESLIFValuep> is C<NULL>.

=head2 Stack manipulation

In the valuation callbacks, stack is manipulated using the functions described below. With no exception, they all return a true value on success, a false value on failure, and all have in common current marpaESLIF valuation context C<marpaESLIFValuep>.

The I<getAndForget> versions are dangerous in the sense that there is a risk of memory leak if your application forget to free a memory popped from the stack with such method. Nevertheless, they are also very handy when wou I<know> this is a pointer that you want ESLIF to totally forget about.

=head3 C<marpaESLIFValue_stack_setb>

  short marpaESLIFValue_stack_setb(marpaESLIFValue_t *marpaESLIFValuep,
                                   int indicei,
                                   marpaESLIFValueResult_t *marpaESLIFValueResultp);

Puts the C<marpaESLIFValueResultp> pointer at stack number C<indicei>.

Returns a true value on success, a false value otherwise.

In case C<marpaESLIFValueResultp> is a container, any non-shallow pointer will have to occur once only.

=head3 C<marpaESLIFValue_stack_getb>

  marpaESLIFValue_stack_getb(marpaESLIFValue_t *marpaESLIFValuep,
                             int indicei,
                             marpaESLIFValueResult_t *marpaESLIFValueResultp);

Copies the value result at indice C<indicei> into the C<marpaESLIFValueResultp> pointer.

Returns a true value on success, a false value otherwise.

=head3 C<marpaESLIFValue_stack_getp>

  marpaESLIFValueResult_t *marpaESLIFValue_stack_getp(marpaESLIFValue_t *marpaESLIFValuep,
                                                      int indicei);

Gets a direct pointer to the value result at indice C<indicei> within the value stack. Handy method for performance.

Returns a non-C<NULL> value on success, C<NULL> otherwise.

=head3 C<marpaESLIFValue_stack_forgetb>

  short marpaESLIFValue_stack_forgetb(marpaESLIFValue_t *marpaESLIFValuep,
                                      int indicei);

Says to ESLIF to forget about any eventual value result at indice C<indicei>.

Returns a true value on success, a false value otherwise.

=head3 C<marpaESLIFValue_stack_getAndForgetb>

  short marpaESLIFValue_stack_getAndForgetb(marpaESLIFValue_t *marpaESLIFValuep,
                                            int indicei,
                                            marpaESLIFValueResult_t *marpaESLIFValueResultp);

Copies the value result at indice C<indicei> into the C<marpaESLIFValueResultp> pointer and tells <marpaESLIF> to forget about it.

Returns a true value on success, a false value otherwise.

=head3 C<marpaESLIF_ftos>

  char *marpaESLIF_ftos(marpaESLIF_t *marpaESLIFp, float f);

Tries to convert accurately C<f> to a string. Result a C<NUL> terminated ASCII string that the user will have to free if success, C<NULL> if failure. This should not be called everytime because it is very slow.

=head3 C<marpaESLIF_dtos>

  char *marpaESLIF_dtos(marpaESLIF_t *marpaESLIFp, double d);

Tries to convert accurately C<d> to a string. Result a C<NUL> terminated ASCII string that the user will have to free if success, C<NULL> if failure. This should not be called everytime because it is very slow.

=head3 C<marpaESLIF_ldtos>

  char *marpaESLIF_ldtos(marpaESLIF_t *marpaESLIFp, long double ld);

Tries to convert accurately C<ld> to a string. Result a C<NUL> terminated ASCII string that the user will have to free if success, C<NULL> if failure. This should not be called everytime because it is very slow.

=head2 External symbols

A recognizer is allowed to perform a match try on any symbol that is a terminal, including those that are not part of the current grammar:

  marpaESLIFSymbol_t          *marpaESLIFSymbol_string_newp(marpaESLIF_t *marpaESLIFp,
                                                            marpaESLIFString_t *stringp,
                                                            char *modifiers);
  marpaESLIFSymbol_t          *marpaESLIFSymbol_regex_newp(marpaESLIF_t *marpaESLIFp,
                                                           marpaESLIFString_t *stringp,
                                                           char *modifiers);
  /* An external symbol can be used directly inside the recognizer phase in the current input stream. The later will automatically expand if needed */
  /* as in normal recognizer lifetime. */
  /* It can be also used outside of any grammar on a free input string */
  /* If there is match, *matchbp will contain a true value, else a false value */
  /* When there is match bytepp will contain a copy of the match and the end-user */
  /* is responsible to free it. Length is in *bytelp */
  short                        marpaESLIFSymbol_tryb(marpaESLIFSymbol_t *marpaESLIFSymbolp,
                                                     char *inputs,
                                                     size_t inputl,
                                                     short *matchbp,
                                                     char **bytepp,
                                                     size_t *bytelp);
  short                        marpaESLIFRecognizer_symbol_tryb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                                marpaESLIFSymbol_t *marpaESLIFSymbolp,
                                                                short *matchbp,
                                                                char **bytepp,
                                                                size_t *bytelp);
  void                         marpaESLIFSymbol_freev(marpaESLIFSymbol_t *marpaESLIFSymbolp);

C<Out-of-grammar> symbols of type terminal, i.e. strings or regular expressions, can be created at any time, exactly as if they where present in the grammar: they a described with a C<stringp> and can contain C<modifiers>, which can be C<NULL>.

The C<modifiers>, if any, must be compliant with the grammar specification for strings and regular expressions, i.e.:

=over

=item Strings

Only C<c> or C<i> modifiers are allowed

=item Regular expressions

Only C<e>, C<i>, C<j>, C<m>, C<n>, C<s>, C<x>, C<D>, C<J>, C<U>, C<a>, C<N>, C<u>, C<b>, C<c> or C<A> modifiers are allowed

=back

At recognition phase, there is a C<marpaESLIFRecognizerp> pointer available, and it can be instructed to try to match external symbols. The end-user is responsible to free eventual C<*bytepp> if it is not C<NULL>.

Outside of recognition phase, you can use C<marpaESLIFp> on a free input, identifier by its pointer C<inputs> and length <inputl>.

=head1 NOTES

=over

=item REENTRANT AND THREAD-SAFETY

All the objects are re-entrant but not thread-safe.

=item Float values

when a C<MARPAESLIF_VALUE_TYPE_DOUBLE> or C<MARPAESLIF_VALUE_TYPE_LONG_DOUBLE> type is pushed to the stack, marpaESLIF will always tries to downgrade to C<float>, or C<double> or C<float>, respectively, if there is no loss of information. This is in particular sensible to the C<MARPAESLIF_VALUE_TYPE_LONG_DOUBLE> type, because the latter is not always well supported by all external languages, e.g. Java.

Special values like infinity or NaN, if supported, are trapped will always be overwriten to a C<MARPAESLIF_VALUE_TYPE_FLOAT> type with their corresponding signed or NaN C<float> native representation.

=item Type of internal rules

It is guaranteed that ESLIF built-in actions (i.e. C<::ascii>, C<::shift>, etc..) never produces a C<marpaESLIFValueResult> of type C<PTR>. This mean that the type <PTR> is solely used for data exchange with hosts that cannot export or import using built-in ESLIF types.

=item Grammar show form

The grammar show form is a concatenation of rule show forms and internal information, for every valid grammar level. For every grammar, the following is outputed:

=over

=item Meta grammar settings

For example:

  /*
   * **********************
   * Meta-grammar settings:
   * **********************
   */
  :start ::= json
  :default ::= action => ::concat
               symbol-action => ::shift
               latm => 1

=item Event settings

For example:

  /*
   * ***************
   * Event settings:
   * ***************
   */
  :lexeme ::= <lstring> pause => after event => lstring$=on

=item Rules

For example:

  /*
   * ******
   * Rules:
   * ******
   */
  <json> ::= <object>
  <json> ::= <array>
  <object> ::= '{' <members> '}' action => do_object
  etc...

=item Lexemes

A I<lexeme> is a symbol that is referencing another symbol of the same name but in <another> grammar level, for example:

  # --------
  # Lexemes:
  # --------
  #
  # <number> ::= <number>@+1
  # <lstring> ::= <lstring>@+1
  # <whitespace> ::= <whitespace>@+1

=item Rule properties

For every rule, Marpa parser internal properties are given, together with the rule description, and components of the rule in terms in symbol indices, for example:

  # -----------------
  # Rules properties:
  # -----------------
  #
  # Rule No 0
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <json> ::= <object>
  #   Components:  LHS = RHS[]
  #                  0 = 1
  # ...
  #
  # Rule No 2
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <object> ::= '{' <members> '}' action => do_object
  #   Components:  LHS = RHS[]
  #                  1 = 3 4 5
  # Rule No 3
  #   Properties: ACCESSIBLE, NULLABLE, PRODUCTIVE
  #   Definition: <members> ::= <pair>* separator => /[,]/ action => do_array
  #   Components:  LHS = RHS[]
  #                  4 = 6
  #
  # ...

Exceptions are shown like this:

  #
  # Rule No 2
  #   Properties: ACCESSIBLE, NULLABLE, PRODUCTIVE
  #   Definition: <start> ::= <thisstart> - <startException>
  #   Components:  LHS = RHS[] - EXCEPTION
  #                  0 = 4 - 5
  #

=item Symbol properties

For every symbol, its ESLIF type, Marpa parser properties and definition are given. When it is a terminal, corresponding regular expression definition is given, as well as eventual JIT usage (c.f. PCRE2 information to understand what it is about). For example:

  # -------------------
  # Symbols properties:
  # -------------------
  #
  # Symbol No 0
  #         Type: ESLIF META
  #   Properties: ACCESSIBLE, PRODUCTIVE, START
  #         Name: <json>
  #
  # ...
  #
  # Symbol No 3
  #         Type: ESLIF TERMINAL
  #   Properties: ACCESSIBLE, PRODUCTIVE, TERMINAL
  #      Pattern: \{
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes
  #
  # ...
  #
  # Symbol No 23
  #         Type: ESLIF TERMINAL
  #   Properties: PRODUCTIVE, TERMINAL
  #      Pattern:
  #     0x000000: 5b 5c 73 5d                                     [\s]
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes

There are two types of terminal:

=over

=item Strings

Strings are always converted to a pattern that is fully ASCII compatible, in which ESLIF decide to eventually escape some characters, or to use them in their C<\x{...}> code point version. Therefore the definition of the PCRE2 pattern is outputed as-is.

=item Regular expression

This type include character class. In such a case, the UTF-8 byte sequence corresponding to what the grammar is defining is sent directly to PCRE2, so the definition is the dump of this UTF-8 byte sequence.

=back

=back

=back

=head1 SEE ALSO

L<genericLogger|https://github.com/jddurand/c-genericLogger>,  L<PCRE2|http://www.pcre.org/>, L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html>, L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, L<marpaESLIF_BINDINGS|https://github.com/jddurand/c-marpaESLIF/tree/master/src/bindings>

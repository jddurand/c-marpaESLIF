=encoding UTF-8

=head1 NAME

marpaESLIF_API - Extended Marpa's Scanless Interface API

=head1 DESCRIPTION

marpaESLIF is a Scanless Interface expressed in a BNF format, that is using L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>, itself being a thin interface on top of L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html> parser.

The whole API is available with this include:

  #include <marpaESLIF.h>

There are four namespaces:

=over

=item ESLIF

The main object.

=item ESLIFGrammar

Grammar creation and inspection.

=item ESLIFRecognizer

Parsing phase.

=item ESLIFValue

Valuation phase.

=back

and a transversal type:

  typedef struct marpaESLIFString {
    char   *bytep;            /* pointer bytes */
    size_t  bytel;            /* number of bytes */
    char   *encodingasciis;   /* Encoding of bytes, itself in ASCII encoding, NUL byte terminated */
    char   *asciis;           /* ASCII transliteration - never NULL if bytep is not NULL */
  } marpaESLIFString_t;

which describe what is a I<string>: this is a sequence of C<bytel> bytes, starting at C<bytep> in memory, in eventual C<encodingasciis> encoding, and transliterated as much as possible into C<asciis>.

=head2 ESLIF

Any application must start by instanciating a main ESLIF. This object is thread-safe, re-entrant, and can be reused as many times as needed, in contrary to other namespaces. The recommended usage is to create an ESLIF instance once for the entire process lifetime.

=head3 C<marpaESLIF_versions>

  const char *marpaESLIF_versions();

Returns a non-C<NULL> string describing the ESLIF version, in the form "MAJOR.MINOR.PATCH".

=head3 C<marpaESLIF_newp>

  typedef struct marpaESLIFOption {
    genericLogger_t *genericLoggerp;  /* Logger. Default: NULL */
  } marpaESLIFOption_t;

  marpaESLIF_t *marpaESLIF_newp(marpaESLIFOption_t *marpaESLIFOptionp);

This method is returning a C<marpaESLIF> object, or C<NULL> in case of failure. The parameter C<marpaESLIFOptionp> is a pointer to a C<marpaESLIFOption_t> structure, or C<NULL>. The C<marpaESLIFOption_t> has, as of this version, the single following component:

=over

=item C<genericLoggerp>

A pointer to a L<genericLogger|https://github.com/jddurand/c-genericLogger> instance. If it is C<NULL>, then ESLIF will never log. Otherwise, all namespaces will inherit this logger object and use it.

=back

=head3 C<marpaESLIF_extend_builtin_actionb>

  short marpaESLIF_extend_builtin_actionb(marpaESLIF_t *marpaESLIFp,
                                          char **actionsArrayp,
                                          size_t actionsArrayl);

ESLIF grammar built-in action names extension is possible using this method, where:

=over

=item C<actionsArrayp>

is a pointer to an array of new actions built-ins, defined as terminals as per the ESLIF grammar. Action extensions are always of type C<MARPAESLIF_ACTION_TYPE_NAME>.

=item C<actionsArrayl>

is the number of elements in the array.

=back

For example:

  static const char *actionsArrayp[] = {
    "'%[]'",
    "'%{}'",
    "'%undef'",
    "'%true'",
    "'%false'",
  };

  marpaESLIF_extend_builtin_actionb(marpaESLIFp, (char **) actionsArrayp, sizeof(actionsArrayp)/sizeof(actionsArrayp[0]))) {

will add C<%[]>, C<%{}> etc... built-in action names, that will I<not> be managed by ESLIF anyway, but by the caller's valuation callback: the action name is a parameter of this callback. The implementation is hardcoding every new buil-in as a new rule in the BNF in this form:

  <action name> ::= NEW_BUILTIN action => ::ascii

=head3 C<marpaESLIF_optionp>

  marpaESLIFOption_t *marpaESLIF_optionp(marpaESLIF_t *marpaESLIFp);

Returns the options used to create the C<marpaESLIFp> instance, or C<NULL> if failure. The returned pointer must I<never> be freed.

=head3 C<marpaESLIF_freev>

  void marpaESLIF_freev(marpaESLIF_t *marpaESLIFp);

The destructor of a marpaESLIF instance C<marpaESLIFp> instance. No-op if C<marpaESLIFp> is C<NULL>.

=head2 ESLIFGrammar

An I<ESLIFGrammar> is a sparse array of grammars, each is identified by a I<level>, that is the indice in this array, i.e. C<0>, C<1>, and so on.

Most of the APIs in this section have two forms, one for the I<current> grammar, one for a grammar at a wanted I<indice> or I<description>. A I<description> is a string identifying a grammar, set using the C<:desc> keyword, e.g.:

  :desc :[0]: 'Description of the grammar at level 0'
  :desc :[7]: 'Description of the grammar at level 7'

The default current grammar is always at level C<0>, that must exist. Level <0> is naturally considered like the I<top level> grammar. Nevertheless it is possible to instanciate a parsing at a I<different> level, then the I<current grammar> in derived namespaces like the recognizer or the valuation is I<the level you asked for>. For example:

  A :[0]:= X          # Could have been A ::= X, '::=' is an alias for ':[0]:'
  X :[1]:= Y@+2       # Could have been X ~ Y@+2, '~' is an alias for ':[1]:'
  Y :[3]:= 'Z'

declares grammars at level C<0>, C<1> and C<3>. Grammar at level C<2> is undefined.

=head3 C<marpaESLIFGrammar_newp>

  typedef struct marpaESLIFGrammarOption {
    void   *bytep;               /* Input */
    size_t  bytel;               /* Input length in byte unit */
    char   *encodings;           /* Input encoding. Default: NULL */
    size_t  encodingl;           /* Length of encoding itself. Default: 0 */
    char   *encodingOfEncodings; /* Encoding of encoding, in ASCII encoding. Default: NULL. */
  } marpaESLIFGrammarOption_t;

  marpaESLIFGrammar_t *marpaESLIFGrammar_newp(marpaESLIF_t              *marpaESLIFp,
                                              marpaESLIFGrammarOption_t *marpaESLIFGrammarOptionp);

Creates a grammar object instance, with parameters:

=over

=item C<marpaESLIFp>

An <required> ESLIF object instance.

=item C<marpaESLIFGrammarOptionp>

A I<required> pointer to a C<marpaESLIFGrammarOption_t> structure, defined as:

=over

=item C<bytep>

A pointer to the start of the grammar. Must be non-NULL.

=item C<bytel>

Number of B<bytes>. Must be > 0.

=item C<encodings>

Pointer to a buffer containing encoding information of the grammar. Can be NULL.

=item C<encodingl>

Number of bytes of the buffer containing encoding information. Can be 0.

=item C<encodingOfEncodings>

ASCII and NUL-terminated string giving the encoding of the encoding information itself. Can be, and is usually, NULL.

=back

=back

Grammars themselves are assumed to always fit within a single block of memory. So there is no I<grammar reader> here: we assume that a single buffer starting at C<bytep>, spanning over C<bytel> bytes, is always possible and enough for a grammar definition.

Returns C<NULL> if failure, a grammar object instance on success.

=head3 C<marpaESLIFGrammar_unsafe_newp>

  marpaESLIFGrammar_t *marpaESLIFGrammar_unsafe_newp(marpaESLIF_t              *marpaESLIFp,
                                                     marpaESLIFGrammarOption_t *marpaESLIFGrammarOptionp);

This is the I<not thread-safe> version of C<marpaESLIFGrammar_newp>: you can call it only when you I<know> that your C<marpaESLIFp> is I<not accessed> concurrently with another call to C<marpaESLIFGrammar_unsafe_newp>.

=head3 C<marpaESLIFGrammar_eslifp>

  marpaESLIF_t *marpaESLIFGrammar_eslifp(marpaESLIFGrammar_t *marpaESLIFGrammarp);

Returns the ESLIF parent object instance of C<marpaESLIFGrammarp>, or C<NULL> if failure. It never returns C<NULL> if C<marpaESLIFGrammarp> is not C<NULL>.

=head3 C<marpaESLIFGrammar_optionp>

  marpaESLIFGrammarOption_t *marpaESLIFGrammar_optionp(marpaESLIFGrammar_t *marpaESLIFGrammarp);

Returns the options used to create the C<marpaESLIFGrammarp> instance, or C<NULL> if failure. The returned pointer must I<never> be freed.

=head3 C<marpaESLIFGrammar_ngrammarib>

  short marpaESLIFGrammar_ngrammarib(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                     int                 *ngrammarip);

Puts the number of sub-grammars in the value pointed by C<ngrammarip>, which can be C<NULL>. The number of grammars is the highest level plus one, and it is B<allowed> to have undefined grammars at any indice but level 0. For example:

  A :[0]:= X          # First grammar
  X :[1]:= Y@+2       # Second grammar
                      # Third grammar (undefined)
  Y :[3]:= 'Z'        # Fourth grammar

would return C<4>: there are four grammars, the third one being undefined.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_defaultsb>

  typedef enum marpaESLIFActionType {
    MARPAESLIF_ACTION_TYPE_NAME = 0,
    MARPAESLIF_ACTION_TYPE_STRING
  } marpaESLIFActionType_t;

  typedef struct marpaESLIFAction {
    marpaESLIFActionType_t type;
    union {
      char               *names;
      marpaESLIFString_t *stringp;
    } u;
  } marpaESLIFAction_t;

  typedef struct marpaESLIFGrammarDefaults {
    marpaESLIFAction_t *defaultRuleActionp;   /* Default action for rules */
    marpaESLIFAction_t *defaultSymbolActionp; /* Default action for symbols */
    marpaESLIFAction_t *defaultFreeActionp;   /* Default action for free */
  } marpaESLIFGrammarDefaults_t;

  short marpaESLIFGrammar_defaultsb(marpaESLIFGrammar_t         *marpaESLIFGrammarp,
                                    marpaESLIFGrammarDefaults_t *marpaESLIFGrammarDefaultsp);

Puts in the structure pointed by C<marpaESLIFGrammarDefaultsp>, if it is not C<NULL>, the current grammar defaults, all of them being a structure of type C<marpaESLIFAction_t> or C<NULL> when not set. An action can be of two types:

=over

=item C<MARPAESLIF_ACTION_TYPE_NAME>

A named action, that the end-user will be responsible to resolve to valid a function pointer. Action name itself is an ASCII NUL terminated string accessible in C<u.names>.

=item C<MARPAESLIF_ACTION_TYPE_STRING>

A string literal. Then the action result is forced to be the UTF-8 corresponding string, always pushed with type C<MARPAESLIF_VALUE_TYPE_ARRAY> on the stack. String literals are illegals for the free action, legal for rule and symbol actions. String itself is a C<marpaESLIFString_t> structure pointer accessible in C<u.stringp>.

=back

=over

=item defaultRuleActionp

Default action for symbols, and correspond to the grammar keyword C<action>. Can be a name of a string literal.

=item defaultSymbolActionp
Default action for symbols, and correspond to the grammar keyword C<symbol-action>. Can be a name of a string literal.

=item defaultFreeActionp

Default action for symbols, and correspond to the grammar keyword C<free-action>. Can only be a name.

=back

The keywords mentionned upper are set within a I<:default> statement, e.g.:

  :default ::= action        => myRuleAction
               symbol-action => ::u8"String Literal"
               free-action   => myFreeAction

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_defaults_by_levelb>

  short marpaESLIFGrammar_defaults_by_levelb(marpaESLIFGrammar_t         *marpaESLIFGrammarp,
                                             marpaESLIFGrammarDefaults_t *marpaESLIFGrammarDefaultsp,
                                             int                          leveli,
                                             marpaESLIFString_t          *descp);

Put in the structure pointed by C<marpaESLIFGrammarDefaultsp>, if it is not C<NULL>, the grammar at level C<leveli> and/or description C<descp> defaults, where a C<NULL> value for a default means it is not set.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_defaults_setb>

  short marpaESLIFGrammar_defaults_setb(marpaESLIFGrammar_t         *marpaESLIFGrammarp,
                                        marpaESLIFGrammarDefaults_t *marpaESLIFGrammarDefaultsp);

Sets all grammar defaults using the structure pointed by C<marpaESLIFGrammarDefaultsp>, if it is not C<NULL>. A C<NULL> value for a default has the same effect as if original grammar never had the associated keyword.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_defaults_by_level_setb>

  short marpaESLIFGrammar_defaults_by_level_setb(marpaESLIFGrammar_t         *marpaESLIFGrammarp,
                                                 marpaESLIFGrammarDefaults_t *marpaESLIFGrammarDefaultsp,
                                                 int                          leveli,
                                                 marpaESLIFString_t          *descp);

Puts in the structure pointed by C<marpaESLIFGrammarDefaultsp>, if it is not C<NULL>. A C<NULL> value for a default has the same effect as if original grammar never had the associated keyword.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammar_by_levelb>

  short marpaESLIFGrammar_grammar_by_levelb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                            int                  leveli,
                                            marpaESLIFString_t  *descp,
                                            int                 *levelip,
                                            marpaESLIFString_t **descpp);

Put in the values pointed by C<levelip> and C<descpp>, which can be both C<NULL>, the level and description of wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if lower than C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

When both C<leveli> and C<descp> are set, C<descp> have precedence over C<leveli>.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammarproperty_currentb>

  typedef struct marpaESLIFGrammarProperty {
    int                    leveli;                       /* Grammar level */
    marpaESLIFString_t    *descp;                        /* Grammar description (auto-generated if none) */
    short                  latmb;                        /* LATM ? */
    marpaESLIFAction_t    *defaultSymbolActionp;         /* Default action for symbols - never NULL */
    marpaESLIFAction_t    *defaultRuleActionp;           /* Default action for rules - never NULL */
    marpaESLIFAction_t    *defaultFreeActionp;           /* Default action for free - can be NULL */
    int                    starti;                       /* Start symbol Id - always >= 0 */
    int                    discardi;                     /* Discard symbol Id (-1 if none) */
    size_t                 nsymboll;                     /* Number of symbols - always > 0*/
    int                   *symbolip;                     /* Array of symbols Ids - never NULL */
    size_t                 nrulel;                       /* Number of rules - always > 0*/
    int                   *ruleip;                       /* Array of rule Ids - never NULL */
  } marpaESLIFGrammarProperty_t;

  marpaESLIFGrammar_grammarproperty_currentb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                             marpaESLIFGrammarProperty_t *grammarPropertyp);

Put in the value pointed by C<grammarPropertyp>, if it is not C<NULL>, current C<marpaESLIFGrammarp>'s grammar properties.

=head3 C<marpaESLIFGrammar_grammarproperty_by_levelb>

  marpaESLIFGrammar_grammarproperty_by_levelb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                              marpaESLIFGrammarProperty_t *grammarPropertyp,
                                              int leveli,
                                              marpaESLIFString_t *descp);

Put in the value pointed by C<grammarPropertyp>, if it is not C<NULL>, C<marpaESLIFGrammarp>'s grammar's at level C<leveli> or with description C<descp> properties.

=head3 C<marpaESLIFGrammar_rulearray_currentb>

  short marpaESLIFGrammar_rulearray_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                             int                 **ruleipp,
                                             size_t               *rulelp);

Puts in the values pointed by C<ruleipp> and C<rulelp> a pointer to an array of integer, and the number of them, respectively, of current grammar. User must B<not> try to free C<*ruleipp>. Please note that this is exactly the same information as the tuple C<{nrulel,ruleip>} returned by C<marpaESLIFGrammar_grammarproperty_currentb>.

Returns a true value on failure, a false value on failure. C<*ruleipp> is never C<NULL> in case of success.

=head3 C<marpaESLIFGrammar_rulearray_by_levelb>

  short marpaESLIFGrammar_rulearray_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                              int                 **ruleipp,
                                              size_t               *rulelp,
                                              int                   leveli,
                                              marpaESLIFString_t   *descp);


Put in the values pointed by C<ruleipp> and C<rulelp> a pointer to an array of integer, and the number of them, respectively, of the grammar referenced by C<leveli> or C<descp>. 

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if lower than C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

When both C<leveli> and C<descp> are set, C<descp> have precedence over C<leveli>.

Returns a true value on failure, a false value on failure. C<*ruleipp> is never C<NULL> in case of success.

=head3 C<marpaESLIFGrammar_ruleproperty_currentb>

  typedef enum marpaESLIFRulePropertyBit {
    MARPAESLIF_RULE_IS_ACCESSIBLE = 0x01,
    MARPAESLIF_RULE_IS_NULLABLE   = 0x02,
    MARPAESLIF_RULE_IS_NULLING    = 0x04,
    MARPAESLIF_RULE_IS_LOOP       = 0x08,
    MARPAESLIF_RULE_IS_PRODUCTIVE = 0x10
  } marpaESLIFRulePropertyBit_t;

  typedef struct marpaESLIFRuleProperty {
    int                    idi;                          /* Rule Id */
    marpaESLIFString_t    *descp;                        /* Rule alternative name (auto-generated if none) */
    char                  *asciishows;                   /* Rule show (ASCII) */
    int                    lhsi;                         /* LHS symbol Id */
    int                    separatori;                   /* Eventual separator symbol Id (-1 if none) */
    size_t                 nrhsl;                        /* Number of RHS, 0 in case of a nullable */
    int                   *rhsip;                        /* Array of RHS Ids, NULL in case of a nullable */
    int                    exceptioni;                   /* Exception symbol Id (-1 if none) */
    marpaESLIFAction_t    *actionp;                      /* Action */
    char                  *discardEvents;                /* Discard event name - shallowed with its RHS */
    short                  discardEventb;                /* Discard event initial state: 0: off, 1: on */
    int                    ranki;                        /* Rank */
    short                  nullRanksHighb;               /* Null ranks high ? */
    short                  sequenceb;                    /* Sequence ? */
    short                  properb;                      /* Proper ? */
    int                    minimumi;                     /* minimum in case of sequence ? */
    short                  internalb;                    /* This rule is internal */
    int                    propertyBitSet;               /* C.f. marpaESLIFRulePropertyBit_t */
  } marpaESLIFRuleProperty_t;


  short marpaESLIFGrammar_ruleproperty_currentb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                int rulei,
                                                marpaESLIFRuleProperty_t *rulePropertyp);

Puts in the value pointed by C<rulePropertyp>, if it is not C<NULL>, properties of rule number C<rulei> of current C<marpaESLIFGrammarp>'s grammar.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_ruleproperty_by_levelb>

  short marpaESLIFGrammar_ruleproperty_by_levelb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                 int rulei,
                                                 marpaESLIFRuleProperty_t *rulePropertyp,
                                                 int leveli,
                                                 marpaESLIFString_t *descp);

Puts in the value pointed by C<rulePropertyp>, if it is not C<NULL>, properties of rule number C<rulei> of C<marpaESLIFGrammarp>'s grammar's level C<leveli> or description C<descp>.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_ruledisplayform_currentb>

  short marpaESLIFGrammar_ruledisplayform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                   int                   rulei,
                                                   char                **ruledisplaysp);

Put in the value pointed by C<ruledisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of rule name at indice C<rulei> of the current grammar.

Returns a true value on failure, a false value on failure.

Example of a rule display form:

  <lstring>

=head3 C<marpaESLIFGrammar_ruledisplayform_by_levelb>

  short marpaESLIFGrammar_ruledisplayform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                    int                   rulei,
                                                    char                **ruledisplaysp,
                                                    int                   leveli,
                                                    marpaESLIFString_t   *descp);

Put in the value pointed by C<ruledisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of rule name at indice C<rulei> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_symbolarray_currentb>

  short marpaESLIFGrammar_symbolarray_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                               int                 **symbolipp,
                                               size_t               *symbollp);

Puts in the values pointed by C<symbolipp> and C<symbollp> a pointer to an array of integer, and the number of them, respectively, of current grammar. User must B<not> try to free C<*symbolipp>. Please note that this is exactly the same information as the tuple C<{nsymboll,symbolip>} returned by C<marpaESLIFGrammar_grammarproperty_currentb>.

Returns a true value on failure, a false value on failure. C<*symbolipp> is never C<NULL> in case of success.

=head3 C<marpaESLIFGrammar_symbolarray_by_levelb>

  short marpaESLIFGrammar_symbolarray_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                int                 **symbolipp,
                                                size_t               *symbollp,
                                                int                   leveli,
                                                marpaESLIFString_t   *descp);


Put in the values pointed by C<symbolipp> and C<symbollp> a pointer to an array of integer, and the number of them, respectively, of the grammar referenced by C<leveli> or C<descp>. 

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if lower than C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

When both C<leveli> and C<descp> are set, C<descp> have precedence over C<leveli>.

Returns a true value on failure, a false value on failure. C<*symbolipp> is never C<NULL> in case of success.

=head3 C<marpaESLIFGrammar_symbolproperty_currentb>

  typedef enum marpaESLIFSymbolPropertyBit {
    MARPAESLIF_SYMBOL_IS_ACCESSIBLE = 0x01,
    MARPAESLIF_SYMBOL_IS_NULLABLE   = 0x02,
    MARPAESLIF_SYMBOL_IS_NULLING    = 0x04,
    MARPAESLIF_SYMBOL_IS_PRODUCTIVE = 0x08,
    MARPAESLIF_SYMBOL_IS_START      = 0x10,
    MARPAESLIF_SYMBOL_IS_TERMINAL   = 0x20
  } marpaESLIFSymbolPropertyBit_t;

  typedef enum marpaESLIFSymbolType {
    MARPAESLIF_SYMBOLTYPE_TERMINAL,
    MARPAESLIF_SYMBOLTYPE_META
  } marpaESLIFSymbolType_t;

  typedef struct marpaESLIFSymbolProperty {
    marpaESLIFSymbolType_t       type;                   /* Symbol type */
    short                        startb;                 /* Start symbol ? */
    short                        discardb;               /* Discard LHS symbol (i.e. :discard) ? */
    short                        discardRhsb;            /* Discard RHS symbol ? */
    short                        lhsb;                   /* Is an LHS somewhere in its grammar ? */
    short                        topb;                   /* Is a top-level symbol in its grammar - implies lhsb */
    int                          idi;                    /* Marpa ID */
    marpaESLIFString_t          *descp;                  /* Symbol description */
    char                        *eventBefores;           /* Pause before */
    short                        eventBeforeb;           /* Pause before initial state: 0: off, 1: on */
    char                        *eventAfters;            /* Pause after */
    short                        eventAfterb;            /* Pause after initial state: 0: off, 1: on */
    char                        *eventPredicteds;        /* Event name for prediction */
    short                        eventPredictedb;        /* Prediction initial state: 0: off, 1: on */
    char                        *eventNulleds;           /* Event name for nulled */
    short                        eventNulledb;           /* Nulled initial state: 0: off, 1: on */
    char                        *eventCompleteds;        /* Event name for completion */
    short                        eventCompletedb;        /* Completion initial state: 0: off, 1: on */
    char                        *discardEvents;          /* Discard event name - shallow pointer to a :discard rule's discardEvents */
    short                        discardEventb;          /* Discard event initial state: 0: off, 1: on - copy of :discard's rule value */
    int                          lookupResolvedLeveli;   /* Resolved grammar level */
    int                          priorityi;              /* Symbol priority */
    marpaESLIFAction_t          *nullableActionp;        /* Nullable semantic */
    int                          propertyBitSet;
  } marpaESLIFSymbolProperty_t;

  short marpaESLIFGrammar_symbolproperty_currentb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                  int symboli,
                                                  marpaESLIFSymbolProperty_t *symbolPropertyp);

Puts in the value pointed by C<symbolPropertyp>, if it is not C<NULL>, properties of symbol number C<symboli> of current C<marpaESLIFGrammarp>'s grammar.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_symbolproperty_by_levelb>

  short marpaESLIFGrammar_symbolproperty_by_levelb(marpaESLIFGrammar_t *marpaESLIFGrammarp,
                                                   int symboli,
                                                   marpaESLIFSymbolProperty_t *symbolPropertyp,
                                                   int leveli,
                                                   marpaESLIFString_t *descp);

Puts in the value pointed by C<symbolPropertyp>, if it is not C<NULL>, properties of symbol number C<symboli> of C<marpaESLIFGrammarp>'s grammar's level C<leveli> or description C<descp>.

Returns a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_symboldisplayform_currentb>

  short marpaESLIFGrammar_symboldisplayform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                     int                   symboli,
                                                     char                **symboldisplaysp);

Put in the value pointed by C<symboldisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of symbol name at indice C<symboli> of the current grammar from C<marpaESLIFGrammarp>.

Return a true value on failure, a false value on failure.

Example of a symbol display form:

  <in_string>

=head3 C<marpaESLIFGrammar_symboldisplayform_by_levelb>

  short marpaESLIFGrammar_symboldisplayform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                      int                   symboli,
                                                      char                **symboldisplaysp,
                                                      int                   leveli,
                                                      marpaESLIFString_t   *descp);

Put in the value pointed by C<symboldisplaysp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> version of symbol name at indice C<symboli> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_ruleshowform_currentb>

  short marpaESLIFGrammar_ruleshowform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                int                   rulei,
                                                char                **ruleshowsp);

Put in the value pointed by C<ruleshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of rule definition at indice C<rulei> of the current grammar from C<marpaESLIFGrammarp>.

Return a true value on failure, a false value on failure.

Example of a rule show form:

  <lstring> ~ <quote> <in_string> <quote>

=head3 C<marpaESLIFGrammar_ruleshowform_by_levelb>

  short marpaESLIFGrammar_ruleshowform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                    int                   rulei,
                                                    char                **ruleshowsp,
                                                    int                   leveli,
                                                    marpaESLIFString_t   *descp);

Put in the value pointed by C<ruleshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of rule definition at indice C<rulei> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammarshowform_currentb>

  short marpaESLIFGrammar_grammarshowform_currentb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                   int                   grammari,
                                                   char                **grammarshowsp);

Put in the value pointed by C<grammarshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of grammar definition at indice C<grammari> of the current grammar from C<marpaESLIFGrammarp>. This is very exhaustive, and give internal information about all symbols and rules. See the NOTES section.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_grammarshowform_by_levelb>

  short marpaESLIFGrammar_grammarshowform_by_levelb(marpaESLIFGrammar_t  *marpaESLIFGrammarp,
                                                    int                   grammari,
                                                    char                **grammarshowsp,
                                                    int                   leveli,
                                                    marpaESLIFString_t   *descp);

Put in the value pointed by C<grammarshowsp>, which can be C<NULL>, a NUL-terminated I<ASCII encoded> transliteration of grammar definition at indice C<grammari> of the wanted grammar from C<marpaESLIFGrammarp>:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

This is very exhaustive, and give internal information about all symbols and rules. See the NOTES section.

Return a true value on failure, a false value on failure.

=head3 C<marpaESLIFGrammar_parseb>

  short marpaESLIFGrammar_parseb(marpaESLIFGrammar_t          *marpaESLIFGrammarp,
                                 marpaESLIFRecognizerOption_t *marpaESLIFRecognizerOptionp,
                                 marpaESLIFValueOption_t      *marpaESLIFValueOptionp,
                                 short                        *exhaustedbp,
                                 marpaESLIFValueResult_t      *marpaESLIFValueResultp);

Please refer to the documentation of:

=over

=item C<marpaESLIFGrammar_newp>

for the C<marpaESLIFRecognizerOption_t> structure documentation.

=item C<ESLIF Value Result>

for the C<marpaESLIFValueResult_t> structure documentation.

=item C<marpaESLIFValue_newp>

for the C<marpaESLIFValueOption_t> structures documentation.

=back

A short form of parsing and valuation, in which I<no event> is possible: the entire scanning is left to the marpaESLIF engine. The grammar at level C<0> is used.

The value pointed by C<exhaustedbp>, when not C<NULL>, is filled with a true value if the parsing exhausted (exhaustion roughly mean that the parsing stopped without consuming all the data), a false value otherwise. This flag does not depend on the existence of an exhaustion event or not.

Returns a true value on success, a false value otherwise.

=head3 C<marpaESLIFGrammar_parse_by_levelb>

  short marpaESLIFGrammar_parse_by_levelb(marpaESLIFGrammar_t          *marpaESLIFGrammarp,
                                          marpaESLIFRecognizerOption_t *marpaESLIFRecognizerOptionp,
                                          marpaESLIFValueOption_t      *marpaESLIFValueOptionp,
                                          short                        *exhaustedbp,
                                          int                           leveli,
                                          marpaESLIFString_t           *descp,
                                          marpaESLIFValueResult_t      *marpaESLIFValueResultp);

Same functionnality as C<marpaESLIFGrammar_parseb> for a wanted grammar from C<marpaESLIFGrammarp>, with these additional parameters:

=over

=item C<leveli>

is the eventual explicit wanted level, ignored if < C<0>.

=item C<descp>

is the eventual explicit description, ignored if C<NULL>.

=back

C<descp> have precedence of C<leveli>.

=head3 C<marpaESLIFGrammar_freev>

  void marpaESLIFGrammar_freev(marpaESLIFGrammar_t *marpaESLIFGrammarp);

The destructor of a marpaESLIFGrammar instance C<marpaESLIFGrammarp> instance. No-op if C<marpaESLIFGrammarp> is C<NULL>.

=head2 ESLIF Value Result

Before going on with the recognizer and valation namespaces, the notion of value result should be explicited first.

A Value result holds two notions:

=over

=item A value type

=item How the value is I<represented>

=back

Supported value types are in the enumeration C<marpaESLIFValueType_t>:

  typedef enum marpaESLIFValueType {
    MARPAESLIF_VALUE_TYPE_UNDEF = 0,
    MARPAESLIF_VALUE_TYPE_CHAR,
    MARPAESLIF_VALUE_TYPE_SHORT,
    MARPAESLIF_VALUE_TYPE_INT,
    MARPAESLIF_VALUE_TYPE_LONG,
    MARPAESLIF_VALUE_TYPE_FLOAT,
    MARPAESLIF_VALUE_TYPE_DOUBLE,
    MARPAESLIF_VALUE_TYPE_PTR,
    MARPAESLIF_VALUE_TYPE_ARRAY
  } marpaESLIFValueType_t;

The names are quite explicit and map all ANSI-C types, with the notion of array, i.e.:

=over

=item MARPAESLIF_VALUE_TYPE_UNDEF

Value is undefined.

=item MARPAESLIF_VALUE_TYPE_CHAR

Value is a C's C<char>.

=item MARPAESLIF_VALUE_TYPE_SHORT

Value is a C's C<short>.

=item MARPAESLIF_VALUE_TYPE_INT

Value is a C's C<int>.

=item MARPAESLIF_VALUE_TYPE_LONG

Value is a C's C<long>.

=item MARPAESLIF_VALUE_TYPE_FLOAT

Value is a C's C<float>.

=item MARPAESLIF_VALUE_TYPE_DOUBLE

Value is a C's C<double>.

=item MARPAESLIF_VALUE_TYPE_PTR

Value is a C's C<void *>.

=item MARPAESLIF_VALUE_TYPE_ARRAY

Value is a C's C<void *> with an associated length.

=back

A Value result is a value type C<marpaESLIFValueResult_t> with more meta data:

  typedef short (*marpaESLIFRepresentation_t)(void *userDatavp,
                                              marpaESLIFValueResult_t *marpaESLIFValueResultp,
                                              char **inputcpp,
                                              size_t *inputlp);
  typedef struct marpaESLIFValueResult {
    int                        contexti;          /* Free value meaningful only to the user */
    size_t                     sizel;             /* Length of data in case value is an ARRAY */
    marpaESLIFRepresentation_t representationp;   /* Value result representation */
    short                      shallowb;          /* Shallow flag In case of PTR or ARRAY */
    marpaESLIFValueType_t      type;              /* Type for tagging the following union */
    union {
      char    c;                                  /* Value is a char */
      short   b;                                  /* Value is a short */
      int     i;                                  /* Value is an int */
      long    l;                                  /* Value is a long */
      float   f;                                  /* Value is a float */
      double  d;                                  /* Value is a double */
      void   *p;                                  /* Value is a pointer */
    } u;
  } marpaESLIFValueResult_t;

which means:

=over

=item contexti

Except for the value C<0>, that is reserved for ESLIF internals, this can be anything that is meaningul for the end-user.

=item sizel

Length of data when the type is C<MARPAESLIF_VALUE_TYPE_ARRAY>.

=item representationp

Associated representation in terms of input: this has an immediate impact on any valuation that depend on the data that has been automatically seen by ESLIF (i.e. I<explicit terminals> and I<lexemes>), or injected by the user (i.e. I<alternatives>). The exhaustive list of rules depending on the input are:

=over

=item C<::concat>

For example, consider the rule:

  X ::= A B C action => ::concat

The C<::concat> action is doing a I<binary concatenation> of all items on the right-hand side. The implementation is the following:

For every item, if it has no representation callback, then only items of type C<MARPAESLIF_VALUE_TYPE_ARRAY> are accepted for concatenation. Otherwise, the representation callback is used i.e.:

  
  representationp(userDatavp /* User-specific valuation context */,
                  marpaESLIFValueResultp /* Pointer to the current value */,
                  &srcs, /* char ** pointer - to be filled by the user */
                  &srcl /* size_t * pointer - to be filled bu the user */)

and if C<srcs> and C<srcs> are not C<NULL> and C<0>, respectively, the corresponding area will be copied I<as-is>.

Explicit terminals are never under the user's control: the matched input is what will be appended as-is.

Lexemes discovered automatically by ESLIF are always in the form of an array: matched input will be appended as-is.

Alternatives pushed by the end-user will follow the upper rules: if the user given a representation callback, the later is used. Else only values of type C<MARPAESLIF_VALUE_TYPE_ARRAY> will be considered and appended as-is.

The notion of I<matched input> refers to the ESLIF I<internal input buffer>: character chunks are always converted to their UTF-8 encoded equivalent data, and it is the UTF-8 version of data that is appended as-is. Binary chunks are taken as-is.

=item C<::convert[THIS]>

This rule is nothing else but a conversion of the C<::concat> result into C<THIS> encoding.

=item C<::ascii>

This rule is nothing else but an alias for C<::convert[ASCII]>.

=back

=item shallowb

Meaningful only when type is C<MARPAESLIF_VALUE_TYPE_PTR> or C<MARPAESLIF_VALUE_TYPE_ARRAY>, this has no impact on representation, but has an impact on internal value stack manipulation: everytime ESLIF tries to set a value, it is looking if this is doing to replace something. It is taking two informations to decide to call a user's eventual free callback: it is the type is C<MARPAESLIF_VALUE_TYPE_PTR> or C<MARPAESLIF_VALUE_TYPE_ARRAY>, and if the value to replaced has been declared shallowed or not. When the value to replace is declared shallowed, the user's free callback is never called.

=item type

This is the type itself, and has an impact on the C's C<union> that follows. Please note that:

=over

=item C<MARPAESLIF_VALUE_TYPE_PTR>

is using only the C<u.p> pointer.

=item C<MARPAESLIF_VALUE_TYPE_ARRAY>

is using both the C<u.p> pointer and the C<sizel> element.

=back

=back

=head2 ESLIFRecognizer

One of the most important thing to understand is the notion of I<lexeme>: a I<lexeme> is a I<meta symbol> referencing another I<meta symbol> in another grammar. As such, it is a I<terminal> from the grammar point of view.

Internally, marpaESLIF have two terminal implementations:

=over

=item explicit terminal

These are terminals defined explicitely in the grammar as strings, character classes or regular expressions. These terminals have no name, and will be handled automatically by the recognizer during a scanning phase.

=item meta symbol

These are symbols that have no LHS counterpart in the current grammar, thus must be known to another grammar. We call them lexemes, and the other grammar is used as a I<lexing grammar>, totqlly managed by ESLIF, I<as if> this was an explicit terminal.

=back

This mean that if the end-user want to have control on the parsing, he <must> make sure that he will declare as a lexeme any part of the grammar on which he migh want to have some influence.

The subtility, so, is in the declaration of terminals. For instance, rules like this:

  <sequence rule> ::= <something>* separator => [\s]+
  <something>     ::= /[a-z]+/
  <something>     ::= 'X'

aren't declaring any lexeme: both C<[\s]+>, C</[a-z]+/> and C<'X'> are I<explicit> terminals in the same grammar level. There is no associated name, and the user will not be able to say "I want to push an alternative whose content is C<'X'> myself". On the other hand:

  <sequence rule> ::= <something>* separator => my_separator
  <something>     ::= /[a-z]+/
  <something>     ::= my_string

  my_separator      ~ [\s]+
  my_string         ~ 'X'

declares the symbols C<my_separator> and C<my_string> as lexemes: they are not in any LHS of the grammar at level 0 (the one with C<::=> declarations), they refer to a I<grammar used as lexer> that is at level 1 (the one with C<~> declarations). The user will be able to push himself alternatives using the symbol names C<my_separator> and C<my_string>. Taking the example of the C<'X'> string, the user have the freedom to push I<something else> but C<'X'>, because he took over the lexing phase. The only important thing from the top grammar point of view, is that the I<terminal> whose name is C<my_string> is an accepted alternative. Still, the end-user will not be able to push an alternative that would correspond to the expression C</[a-z]+/> at the C<something> location.

Since when a user push alternative himself lexing is bypassed, this mean that the I<representation> of this alternative is also totally under the user's control. Indeed, nothing prevent the user to push the alternative named C<my_string> and say its representation is something else but C<X>. This is the purpose of the C<marpaESLIFValueResult> structure: it is describing what ESLIF is calling a I<result>, and makes a clear distinction between a result and its representation.

Being able to affect the parse tree is only possible anywhen the recognizer holds on, i.e. anywhen there is an I<event>.

At any location in the grammar, possible alternatives can be of the two major types: I<explicit terminals> and lexemes (i.e. a I<meta symbol> refering another grammar). If the two types are present, and if at least one I<explicit terminal> matches, then the longests I<explicit terminal> will have absolute precedence over any lexeme. In other terms, I<explicit terminals> have an implicit absolute priority when they appear directly in a rule definition.

=head3 C<marpaESLIFRecognizer_newp>

  typedef short (*marpaESLIFReader_t)(void    *userDatavp,
                                      char   **inputcpp,
                                      size_t  *inputlp,
                                      short   *eofbp,
                                      short   *characterStreambp,
                                      char   **encodingOfEncodingsp,
                                      char   **encodingsp,
                                      size_t  *encodinglp);
  typedef struct marpaESLIFRecognizerOption {
    void                *userDatavp;                  /* User specific context */
    marpaESLIFReader_t   marpaESLIFReaderCallbackp;   /* Reader callback */
    short                disableThresholdb;           /* Disable threshold warning.  Recommended: 0 */
    short                exhaustedb;                  /* Exhaustion event.           Recommended: 0 */
    short                newlineb;                    /* Count line/column numbers.  Recommended: 0 */
    short                trackb;                      /* Absolute position tracking. Recommended: 0 */
    size_t               bufsizl;                     /* Minimum stream buffer size. Recommended: 0 */

    /* Excess number of bytes, in % of bufsizl, where stream buffer size is reduced */
    unsigned int         buftriggerperci;             /*                             Recommended: 50 */

    /* Policy of minimum of bytes for increase, in % of current allocated size, when */
    /*  stream buffer size need to augment */
    unsigned int         bufaddperci;                 /*                             Recommended: 50 */
  } marpaESLIFRecognizerOption_t;

  marpaESLIFRecognizer_t *marpaESLIFRecognizer_newp(marpaESLIFGrammar_t          *marpaESLIFGrammarp,
                                                    marpaESLIFRecognizerOption_t *marpaESLIFRecognizerOptionp);

Creates a recognizer out of a C<marpaESLIFGrammarp> grammar instance.

The C<marpaESLIFReader_t> defines the prototype of a reader, referenced in the required parameter C<marpaESLIFRecognizerOptionp>. Its arguments are:

=over

=item C<userDatavp>

User opaque pointer, set in C<marpaESLIFRecognizerOptionp> and propagated as-is to the reader. There is no default value.

=item C<inputcpp>

The place where the user will set the pointer of the next available buffer. Default is C<NULL>.

=item C<inputlp>

The place where the user will set the number of bytes of the next available buffer. Default is C<0>.

=item C<eofbp>

The place where the user will set a flag saying this the end of data. Default is a false value.

=item C<characterStreambp>

The place where the user will set a flag saying this buffer I<must> be a stream of characters. Default is a false value.

=item C<encodingOfEncodingsp>

The place where the user will give in which encoding is the encoding itself. Default is <NULL>.

=item C<encodingsp>

The place where the user will give a pointer to a buffer containing encoding information, encoded using C<encodingOfEncodingsp> encoding. Default is C<NULL>.

=item C<encodinglp>

The place where the user will give a size of the buffer starting at C<*encodingsp>. Default is C<0>.

=back

Mixing binary and character streams is possible but only at the chunk level, where a chunk is the data buffer returned by the reader callback. It is up the user to be able to determine the boundaries. Here is how the character stream flag and encoding information is used by marpaESLIF at the return of the reader callback:

=over

=item 1 - User say this is a character stream

=over

=item A - Previous read was also a character streams

=over

=item a - User gave encoding (C<*encodingsp> is not C<NULL>)

If previous encoding is different, it is flushed and a new one is starting. Else previous encoding continue, this more will support incomplete character from the previous chunk.

=item b - User gave no encoding (C<*encodingsp> is C<NULL>)

It is assumed that previous encoding continue

=back

=item B - Previous read was not a stream of characters (or there was no previous read)

If user gave encoding information it is used, else encoding is guessed.

=back

=item 2 - User say this is not a character stream

=over

=item A - Previous read was a character stream

It is flushed, and binary data is appended as-is.

=item B - Previous read was not a character stream (or there was no previous read)

Binary data is appended as-is.

=back

=back

I<If> the grammar requires UTF-8 understanding of the buffer (either by using characters with code points greater than C<0xFF> in terminals, or explicitely setting the C<c> modifier to regular expressions - all of that meaning that PCRE2 expressions have the PCRE2_UTF flag), and C<If> the chunk of data was not declared as a character stream: it is assumed that it is in UTF-8 encoding. PCRE2 will check that and yell if it does not contain only valid UTF-8 characters.

The parameter C<marpaESLIFRecognizerOptionp> is a pointer to a C<marpaESLIFRecognizerOption_t> structure, where:

=over

=item C<userDatavp>

User context, propagated as-is to reader callback.

=item C<marpaESLIFReaderCallbackp>

Pointer to the reader callback. Must not be C<NULL>.

=item C<disableThresholdb>

Disable treshold warning generated by L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html>. Recommended value is a false value, because when such warning arises, it usually indicate some problem with the grammar.

=item C<exhaustedb>

Support of exhaustion event. Recommended value is a false value, because the most common usage of parsing data is to parse the full buffer up to its end of data. Nevertheless is is quite easy to find applications that support the exhaustion, for example parsing of binary structures that contain sub-structures, and so on. Setting this flag is also the I<only> way to have the C<marpaESLIFGrammar_parseb> method successful even if not all data is consumed.

=item C<newlineb>

Support of newline count. This is used when the parser fails to produce ab accurate report with line and number information. Works at the granularity of data chunk, and is meaningless if data chunk is not declared as a character stream. Any Unicode line ending sequence is considered.

=item C<trackb>

Support of absolute position tracking. The recognizer have to track absolute position to successfuly process the C<marpaESLIFRecognizer_last_completedb()> method (see below). Nevertheless, maintaining such information has a cost and is not fully reliable because there is no attempt to check for an eventual turnaround of the associated internal variables. You should put this option to a true value only if you plan to use C<marpaESLIFRecognizer_last_completedb()>.

=item C<bufsizl>

Default number of bytes of the internal buffer in marpaESLIF, in which I<all> data is stored and appended. If C<0>, the value used when compiling marpaESLIF library is used, itself defaulting to 1Mb. Recommended value is C<0>.

=item C<buftriggerperci>

In order to prevent internal buffer to grow indefinitely, C<buftriggerperci> is the percentage of C<bufsizl> that give a trigger on the number of unused bytes at which the internal buffer is reduced to its initial size C<bufsizl>. Recommended value is C<50>.

=item C<bufaddperci>

To prevent too many memory allocations, when marpaESLIF need to increase its internal buffer, it will do so by requesting C<bufaddperci> percent of current allocated size more bytes. Recommended value: C<50>.

=back

This method returns a recognizer pointer in case of success, C<NULL> in case of failure.

=head3 C<marpaESLIFRecognizer_grammarp>

  marpaESLIFGrammar_t *marpaESLIFRecognizer_grammarp(marpaESLIFRecognizer_t *marpaESLIFRecognizerp);

Returns the ESLIFGrammar instance parent of the C<marpaESLIFRecognizerp> instance, C<NULL> in case of failure. It never returns C<NULL> if C<marpaESLIFRecognizerp> is not C<NULL>. This is <never> the original C<marpaESLIFGrammarp> used when creating the C<marpaESLIFRecognizerp> instance, though it is guaranteed to be a grammar whose functionnality is I<equivalent> to original grammar after applying the recognizer options.

=head3 C<marpaESLIFRecognizer_optionp>

  marpaESLIFRecognizerOption_t *marpaESLIFRecognizer_optionp(marpaESLIFRecognizer_t *marpaESLIFRecognizerp);

Returns the options used to create the C<marpaESLIFRecognizerp> instance, or C<NULL> if failure. The returned pointer must I<never> be freed.

=head3 C<marpaESLIFRecognizer_scanb>

  short marpaESLIFRecognizer_scanb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                   short initialEventsb,
                                   short *continuebp,
                                   short *exhaustedbp);

Start a scanless parsing using the C<marpaESLIFRecognizerp> instance. Only one such call can be done in the whole lifetime of a recognizer. Parameters are:

=over

=item initialEventsb

Traditionnally initial events are not of use and are skipped. When true, this flag enable such events.

=item continuebp

The scanning will pause as soon as there is an event or an error. When not C<NULL>, the value pointed by C<continuebp> say that if scanning can continue if it is a true value.

=item exhaustedbp

If not C<NULL>, this value pointed by C<exhaustedbp> will say if the parse is exhausted, regardless if there is an exhaustion event or not.

=back

A typical usage of the C<marpaESLIFRecognizer_scanb> method is:

  short continueb;
  short exhaustedb;

  if (! marpaESLIFRecognizer_scanb(marpaESLIFRecognizerp,
                                   0 /* initialEventsb */,
                                   &continueb,
                                   &exhaustedb)) {
    goto error_processing;
  }
  while (continueb) {
    /* See below for the events, pause and resume methods */
  }

This method returns a true value on success, a false value on failure, and can generate grammar and pause events.

=head3 C<marpaESLIFRecognizer_resumeb>

  short marpaESLIFRecognizer_resumeb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                     size_t deltaLengthl,
                                     short *continuebp,
                                     short *exhaustedbp);

Resume the scanning. All parameters have the same meaning as for C<marpaESLIFRecognizer_scanb>, with an additional C<deltaLengthl> that say to the recognizer to skip this given number of byte before going on. A typical usage is:

  short continueb;
  short exhaustedb;

  if (! marpaESLIFRecognizer_scanb(marpaESLIFRecognizerp,
                                   0 /* initialEventsb */,
                                   &continueb,
                                   &exhaustedb)) {
    goto error_processing;
  }
  while (continueb) {
    /* See below for the events and pause */
    /* ... */
    /* Resume */
    if (! marpaESLIFRecognizer_resumeb(marpaESLIFRecognizerp,
                                       0,
                                       &continueb,
                                       &exhaustedb)) {
      goto error_processing;
    }
  }

This method can generate grammar and pause events.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_alternativeb>

  typedef struct marpaESLIFAlternative {
    char                   *lexemes;        /* Lexeme name */
    marpaESLIFValueResult_t value;          /* Value */
    size_t                  grammarLengthl; /* Length in the grammar (1 == token-stream model) */
  } marpaESLIFAlternative_t;

  short marpaESLIFRecognizer_lexeme_alternativeb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                                 marpaESLIFAlternative_t *marpaESLIFAlternativep);

It is possible to inject arbitrarty lexemes outside of the internal scanner. Such external lexemes are described using a C<marpaESLIFAlternative_t> structure, containing:

=over

=item lexemes

The lexeme name as per the grammar. Must be different than C<NULL>.

=item value

A structure describing the value. Please refer to the "ESLIF Value Result" section for explanation.

=item grammarLengthl

The number of grammar tokens taken by this alternative. A highly recommended value is C<1>, which correspond to the tradional "token-stream" model. This number must be greater than zero, and putting a value greater than C<1>, will make the parser believe that your alternative has consumed as many terminals.

=back

Because this is representing a lexeme, which is always of type ARRAY in the value stack (i.e. a pointer to bytes together with an associated length), here is how the rule and symbol callbacks can distinguish from user-defined alternatives from the alternatives coming from the internal recognition: the pointer is non-C<NULL>, but the length is C<0>, and the context is C<0> in a rule callback, i.e

=over

=item Rule callbacks

The stack type of the item at an indice C<indicei> is ARRAY, the context is C<0> (i.e. a reserved value), and the array is dereferenced to a non-C<NULL> pointer with a zero length:

  short myRuleCallback(void              *userDatavp,
                       marpaESLIFValue_t *marpaESLIFValuep,
                       int                arg0i,
                       int                argni,
                       int                resulti,
                       short              nullableb) {

    short              arrayb;
    void              *bytep;
    size_t             bytel;
    int                contexti;
    marpaESLIFValue_t *marpaESLIFValuep;

    if (! nullableb) {
      /* There is something in the stack - let's try arg0i */

      marpaESLIFValuep = marpaESLIFValue_stack_getp(marpaESLIFValuep, arg0i);
      if (marpaESLIFValuep == NULL) {
        goto err;
      }
      if (marpaESLIFValuep->type == MARPAESLIF_VALUE_TYPE_ARRAY) {
        if ((! marpaESLIFValuep->contexti) && (marpaESLIFValuep->u.p != NULL) && (marpaESLIFValuep->sizel <= 0)) {
          /* This is a user-defined lexeme, referenced by u.p */
          marpaESLIFValuep = (marpaESLIFValue_t *) marpaESLIFValuep->u.p;
          /* Here, only the user knows what it is about */
        }
      }
    }
    /* ... */
    return 1;

  err:
    return 0;
  }

=item Symbol callbacks

Same logic, except that you receive directly the "array" description on the stack:

  short mySymbolCallback(void              *userDatavp,
                         marpaESLIFValue_t *marpaESLIFValuep,
                         char              *bytep,
                         size_t             bytel,
                         int                resulti) {

    marpaESLIFValue_t *marpaESLIFValuep;

    if ((bytep != NULL) && (bytel <= 0)) {
      /* This is a user-defined lexeme */
      marpaESLIFValuep = (marpaESLIFValue_t *) bytep;
      /* Here, only the user knows what it is about */
    }
  }

=back

Please note that user-defined lexemes can trigger a I<lexeme after> event, though the information retreived with C<marpaESLIFRecognizer_lexeme_last_pauseb> will never show anything else than what correspond to real input stream, c.f. the C<lengthl> parameter of the method C<marpaESLIFRecognizer_lexeme_completeb> described just after. In order words, the representation is never a used notion during lexing, in contrary to the valuation phase.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_completeb>

  short marpaESLIFRecognizer_lexeme_completeb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                              size_t lengthl);

Say to the recognizer pointed C<marpaESLIFRecognizerp> by that the current set of lexeme alternatives is complete, and that the stream should advance by C<length> bytes, where bytes is really the number of bytes in the internal recognizer buffer, i.e. an UTF-8 sequence of code points in case of a character-oriented stream. The reader callback may be called if necessary, in case the caller say to advance by more bytes than what is currently available. It is an error to specify more bytes than the recognizer can get (and eventually transform, in case of character-stream oriented buffer) from the reader. A a value of C<0> for the length is legal.

If a I<lexeme after> event is triggered, C<marpaESLIFRecognizer_lexeme_last_pauseb> will show as many bytes as C<lengthl>. And because it is guaranteed that C<marpaESLIFRecognizer_lexeme_last_pauseb> returns a pointer to NUL-terminated buffer, the extreme case is that last pause can be an empty string "" when the alternative has been pushed using a user-defined value.

This method can generate grammar and pause events.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_readb>

  short marpaESLIFRecognizer_lexeme_readb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          marpaESLIFAlternative_t *marpaESLIFAlternativep);
                                          size_t lengthl);

A short-hand version of lexeme management that is pushing an alternative and do completion in one call.

This method can generate grammar and pause events.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_tryb>

  short marpaESLIFRecognizer_lexeme_tryb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                         char *lexemes,
                                         short *matchbp);

Try to match the lexeme with name C<lexemes> that must be non-C<NULL> against the input seen by the recognizer. Returns in C<matchbp>, when not C<NULL>, a true value if there is a match, a false value otherwise. This method generates no event.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_discard_tryb>

  short marpaESLIFRecognizer_discard_tryb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          short *matchbp);

Try to match the :discard rule against the input seen by the recognizer. Returns in C<matchbp>, when not C<NULL>, a true value if there is a match, a false value otherwise. This method generates no event.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_lexeme_expectedb>

  short marpaESLIFRecognizer_lexeme_expectedb(marpaESLIFRecognizer_t   *marpaESLIFRecognizerp,
                                              size_t                   *nLexemelp,
                                              char                   ***lexemesArraypp);

For the current recognizer C<marpaESLIFRecognizerp>, get the list of I<lexemes> expected. C<*nLexemelp>, if not C<NULL>, is filled with the number of expected lexemes, and C<*lexemesArraypp>, if not C<NULL>, will contain the array of NUL-terminated ASCII symbol names.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_isEofb>

  short marpaESLIFRecognizer_eofb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp, short *eofbp);

Returns in the value pointed by C<eofbp> the current EOF state, when it is not C<NULL>.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_event_onoffb>

  typedef enum marpaESLIFEventType {
    MARPAESLIF_EVENTTYPE_NONE       = 0x00,
    MARPAESLIF_EVENTTYPE_COMPLETED  = 0x01, /* Grammar event */
    MARPAESLIF_EVENTTYPE_NULLED     = 0x02, /* Grammar event */
    MARPAESLIF_EVENTTYPE_PREDICTED  = 0x04, /* Grammar event */
    MARPAESLIF_EVENTTYPE_BEFORE     = 0x08, /* Just before lexeme is commited */
    MARPAESLIF_EVENTTYPE_AFTER      = 0x10, /* Just after lexeme is commited */
    MARPAESLIF_EVENTTYPE_EXHAUSTED  = 0x20, /* Exhaustion */
    MARPAESLIF_EVENTTYPE_DISCARD    = 0x40  /* Discard */
  } marpaESLIFEventType_t;

  short marpaESLIFRecognizer_event_onoffb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          char                   *symbols,
                                          marpaESLIFEventType_t   eventSeti,
                                          short                   onoffb);

For the recognizer pointed by C<marpaESLIFRecognizerp>, switches on or off the event types C<eventSeti> (which is a bit mask of event type), depending of C<onoffb> value, at symbol with name C<symbols> (a NUL terminated ASCII string) of current grammar. Setting on or off a non-existing event is a no-op. There are eight type of events, described with the enum C<marpaESLIFEventType_t>:

=over

=item C<MARPAESLIF_EVENTTYPE_NONE>

No event -;

=item MARPAESLIF_EVENTTYPE_COMPLETED

Completion event. This can happen only for meta symbol names. In the grammar this is declared with:

  event start$ = completed symbolname

=item MARPAESLIF_EVENTTYPE_NULLED

Nulled event. This can happen only for meta symbol names. In the grammar this is declared with:

  event start$ = nulled symbolname

=item MARPAESLIF_EVENTTYPE_PREDICTED

Prediction event. This can happen only for meta symbol names. In the grammar this is declared with:

  event start$ = predicted symbolname

=item MARPAESLIF_EVENTTYPE_BEFORE

I<Lexeme before> event. This can happen only for lexemes that are predicted by the scanning. In the grammar this is declared with:

  :lexeme ::= lexemename pause => before event => eventname

=item MARPAESLIF_EVENTTYPE_AFTER

I<Lexeme before> event. This can happen only for lexemes after they are pushed as alternatives by the scanning. In the grammar this is declared with:

  :lexeme ::= lexemename pause => after event => eventname

=item MARPAESLIF_EVENTTYPE_EXHAUSTED

Exhaustion event. It has no name, and is possible only if the recognizer is instanciated with the C<exhaustedb> flag being a true value in the C<marpaESLIFRecognizerOption_t> structure.

=item MARPAESLIF_EVENTTYPE_DISCARD

Discard event. This can happen only for C<:discard> rules, and happen everytime a C<:discard> rule is completed at the top-level grammar. In the grammar this is declared with:

  :discard ::= whitespace event => discard_whitespace

=back

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_eventb>

  typedef struct marpaESLIFEvent {
    marpaESLIFEventType_t type;
    char                 *symbols; /* Symbol name, NULL if exhausted event, ':discard' if discard event */
    char                 *events;  /* Event name, always NULL if exhaustion eent */
  } marpaESLIFEvent_t;

  short marpaESLIFRecognizer_eventb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                    size_t                  *eventArraylp,
                                    marpaESLIFEvent_t      **eventArraypp);

Retreive the current list of events within the recognizer pointed by C<marpaESLIFRecognizerp>, putting in the value pointed by C<eventArraylp>, if it is not NULL, the number of event, and in the value pointed by C<eventArraypp>, if it not NULL, the list of these events. An event is always a structure of type C<marpaESLIFEvent_t> containing:

=over

=item type

The type of event. C.f. upper section for a description of C<marpaESLIFRecognizer_t> type.

=item symbols

The name of the symbol that triggered the event. Always a NUL-terminated ASCII string, except for exhaustion where it is C<NULL>.

=item events

The name of the event. Always a NUL-terminated ASCII string, except for exhaustion where it is C<NULL>.

=back

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_progressLogb>

  short marpaESLIFRecognizer_progressLogb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                          int                     starti,
                                          int                     endi,
                                          genericLoggerLevel_t    logleveli);

Send to the logger configured at the marpaESLIF instanciation step, the current progress of parsing of the C<marpaESLIFRecognizerp> recognizer instance. Logging is do at level C<logleveli> (c.f. L<genericLogger|https://github.com/jddurand/c-genericLogger> documentation), and from C<starti> to C<endi> indices. The C<starti> and C<endi> indices are Earleme Set Ids, and obey the Perl language convention, i.e. a negative indice means it far back from the end. The format of the strings generated is totally under the L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper> library. This method should be used when the end user want to have a progress report during valuation, c.f. the C<marpaESLIFValue_value_startb> and C<marpaESLIFValue_value_lengthb> methods.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_inputb>

  short marpaESLIFRecognizer_inputb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                    char                   **inputsp,
                                    size_t                  *inputlp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns the current internal buffer state, i.e.:

=over

=item inputsp

If not C<NULL>, will contain the current input internal buffer pointer.

=item inputlp

If not C<NULL>, will contain the current input internal buffer length.

=back

These pointers are intentionaly not having a I<const> keyword, though it is obvious that any attempt to modify C<*inputsp> or C<*inputlp> is likely to make the process crash. The internal buffer may I<not> correspond to what the callback returned in case there is character conversion: in this case the internal buffer contains UTF-8 character sequences.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_locationb>

  short marpaESLIFRecognizer_locationb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                       size_t *linelp,
                                       size_t *columnlp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns the current line and number, i.e.:

=over

=item linelp

If not C<NULL>, will contain the current absolute line number.

=item columnlp

If not C<NULL>, will contain the current absolute column number.

=back

Please note that this is in effect only if the recognizer option have a true value for C<newlineb>, and for character chunks.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_lexeme_last_pauseb>

  short marpaESLIFRecognizer_lexeme_last_pauseb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                                char                    *lexemes,
                                                char                   **pausesp,
                                                size_t                  *pauselp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns a pointer to the last portion of input stream that generated a I<lexeme pause> event for lexeme C<lexemes> in the value pointed by C<pausesp> if it is not NULL, and the length in the value pointed by C<pauselp> if it is not NULL. For convenience if the last pause is not NULL, the buffer holding the pause information is always NUL-terminated, even if the C<\0> NUL character is I<not> in the returned length. In case of user-defined alternatives, the empty string "" is returned in C<pausesp>.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_lexeme_last_tryb>

  short marpaESLIFRecognizer_lexeme_last_tryb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                              char                    *lexemes,
                                              char                   **trysp,
                                              size_t                  *trylp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns a pointer to the last portion of input stream into the value pointed by C<trysp>, when it is non-C<NULL>, and corresponding length in the value pointed by C<trylp> when it is is non-C<NULL>, of the last successful try for lexeme C<lexemes>, via a call to C<marpaESLIFRecognizer_lexeme_tryb>. If C<*trysp> is non-NULL, it is guaranteed that C<*trylp> is greater than zero, and the block of memory is NUL-terminated, even if the additional NUL byte will not be included into C<trylp>.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_discard_last_tryb>

  short marpaESLIFRecognizer_discard_last_tryb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                               char                   **trysp,
                                               size_t                  *trylp);

For the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns a pointer to the last portion of input stream into the value pointed by C<trysp>, when it is non-C<NULL>, and corresponding length in the value pointed by C<trylp> when it is is non-C<NULL>, of the last successful discard try, via a call to C<marpaESLIFRecognizer_discard_tryb>. If C<*trysp> is non-NULL, it is guaranteed that C<*trylp> is greater than zero, and the block of memory is NUL-terminated, even if the additional NUL byte will not be included into C<trylp>.

This function should never fail, a false value indicates something fatal happened or the arguments are not correct.

=head3 C<marpaESLIFRecognizer_readb>

  short marpaESLIFRecognizer_readb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                   char                   **inputsp,
                                   size_t                  *inputlp);

Forces a call to the reader callback. All parameters have the semantic as in the method C<marpaESLIFRecognizer_inputb>.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_last_completedb>

  short marpaESLIFRecognizer_last_completedb(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                             char                    *names,
                                             char                   **offsetpp,
                                             size_t                  *lengthlp);

Convenience method that, for the recognizer instance pointed by C<marpaESLIFRecognizerp>, returns the I<absolute offset> since the beginning of the scanning in the value pointed by C<offsetpp> if it not C<NULL>, and the length in the value pointed by C<lengthlp> if it is not C<NULL>, of the last completion for symbol C<names>, that must not be C<NULL>. This I<absolute offset> is computed without consideration of any turnaround, thus if the amount of data that has been scanned is larger what a C<char *> can adress, the offset value will not be reliable. Same remark for the length.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_hook_discardb>

  marpaESLIFRecognizer_hook_discardb(marpaESLIFRecognizer_t *marpaESLIFRecognizerp,
                                     short discardOnOffb);

Hook the recognizer to enable or disable the use of C<:discard> if it exists. Default mode is on. This is a I<permanent> setting.

Returns a true value on success, a false value on failure.

=over

=item linelp

If not C<NULL>, will contain the current absolute line number.

=item columnlp

If not C<NULL>, will contain the current absolute column number.

=back

Please note that this is in effect only if the recognizer option have a true value for C<newlineb>, and for character chunks.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFRecognizer_freev>

  void marpaESLIFRecognizer_freev(marpaESLIFRecognizer_t *marpaESLIFRecognizerp);

The destructor of a marpaESLIFRecognizer instance C<marpaESLIFRecognizerp> instance. No-op if C<marpaESLIFRecognizerp> is C<NULL>.

=head2 ESLIFValue

At any point in the parsing lifetime it is possible to call for parse tree values. Traditionnaly this is happening when all data has been scanned, or when the parsing has exhausted.

=head3 C<marpaESLIFValue_newp>

  typedef short (*marpaESLIFValueRuleCallback_t)  (void              *userDatavp,
                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                   int                arg0i,
                                                   int                argni,
                                                   int                resulti,
                                                   short              nullableb);

  typedef short (*marpaESLIFValueSymbolCallback_t)(void              *userDatavp,
                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                   char              *bytep,
                                                   size_t             bytel,
                                                   int                resulti);

  typedef void  (*marpaESLIFValueFreeCallback_t)  (void              *userDatavp,
                                                   int                contexti,
                                                   void              *p,
                                                   size_t             sizel);

  typedef marpaESLIFValueRuleCallback_t   (*marpaESLIFValueRuleActionResolver_t)  (void              *userDatavp,
                                                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                                                   char              *actions);

  typedef marpaESLIFValueSymbolCallback_t (*marpaESLIFValueSymbolActionResolver_t)(void              *userDatavp,
                                                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                                                   char              *actions);

  typedef marpaESLIFValueFreeCallback_t   (*marpaESLIFValueFreeActionResolver_t)  (void              *userDatavp,
                                                                                   marpaESLIFValue_t *marpaESLIFValuep,
                                                                                   char              *actions);

  typedef struct marpaESLIFValueOption {
    void                                 *userDatavp;            /* User specific context */
    marpaESLIFValueRuleActionResolver_t   ruleActionResolverp;
    marpaESLIFValueSymbolActionResolver_t symbolActionResolverp;
    marpaESLIFValueFreeActionResolver_t   freeActionResolverp;
    short                                 highRankOnlyb;         /* Recommended: 1 */
    short                                 orderByRankb;          /* Recommended: 1 */
    short                                 ambiguousb;            /* Recommended: 0 */
    short                                 nullb;                 /* Recommended: 0 */
    int                                   maxParsesi;            /* Recommended: 0 */
  } marpaESLIFValueOption_t;

  marpaESLIFValue_t *marpaESLIFValue_newp(marpaESLIFRecognizer_t  *marpaESLIFRecognizerp,
                                          marpaESLIFValueOption_t *marpaESLIFValueOptionp);

where C<userDatavp> is a user opaque value, holding user specific context. Action resolvers are looked up later in this section. The other parameters are:

=over

=item highRankOnlyb

Actions can have a I<rank>, e.g.:

  my_rule ::= I J 'string terminal' rank => 2
  my_rule ::= K L 'string terminal' rank => 1

say that C<my_rule> have two alternatives, with different ranks.

I<If> the next parameter C<orderByRankb> is a true value, then only rule with highest rank will be taken into account. This is a nice nice way to have a grammar ambiguous by nature, though having a non-ambiguous parse tree value from it.

=item orderByRankb

Specify if the rank is to be used.

=item ambiguousb

Specify if parse tree valuation can be ambiguous. Application's choice -;

=item nullb

Allow a parse tree valuation to produce nothing. It is recommended to set this to a false value.

=item maxParsesi

In case of ambiguity, there can be a lot of parse tree valuation results. If greater than zero, C<maxParsesi> is a higher limit on such number.

=back

Valuation lifetime is on the top-level grammar and has two main entry points:

=over

=item Valuation of terminals

Terminals are what comes directly from the input stream. From grammar point of view, this correspond to string, character class, regular expressions, or lexemes.

=item Valuation of rules

Indeed, the valuation lifetime of something like e.g.:

  this_rule ::= 'string terminal'

is:

=over

=item 1 - Evaluate C<'string terminal'>

=item 2 - Evaluate C<this_rule>

=back

and nothing impose that the valuation result of C<my_rule> would be same as C<'string terminal'> valuation result.

=back

The functions holding valuation results are totally unknown from marpaESLIF, which is always asking to user-space for a function pointer of the correct type, whenever needed. For that it is using I<action resolvers>. An action resolver is always called for a given I<action name> C<actions>, guaranteed to a NUL-terminated ASCII string. In other terms marpaESLIF will always call the actions resolver like this:

=over

=item For rules

  ruleActionp = ruleActionResolverp(userDatavp, marpaESLIFValuep, actions)

=item For symbols

  symbolActionp = symbolActionResolverp(userDatavp, marpaESLIFValuep, actions)

=item For free

  freeActionp = freeActionResolverp(userDatavp, marpaESLIFValuep, actions)

=back

and nothing impose the action resolvers to always return the same function pointer for a given C<action> NUL-terminated ASCII string.

The value result itself is also not under marpaESLIF control, though the later requires the user to manipulate a I<stack>, and to assign to every entry in the stack a I<value type>, and a I<value context>. So there is a notion of I<user stack>, which start at indice number C<0>, and whose length is determined by the parse tree value location. The context of every I<value> in the stack is nothing else but a free number different than zero that should describe what it is, and has a meaning only for the end-user. It is important to set a correct context when assigning values to the stack, because this is how the I<memory free> function pointer, another function leaving in user space, will know how to react. For example a rule like this:

  my_rule ::= I J 'string terminal' action => my_action

could be called with output stack indice C<0> and input stack indices C<0> for C<I>, C<1> for C<J>, and C<2> for C<K>. It is the end user that knows what it is all about, through the famous I<context>. Suppose that types of data would be a pointer (C<PTR> below) with context value C<17>, an integer (C<INT> below) with context value C<216>, and a short (C<SHORT> below) with context value C<43>, and that the end user decided that the result is a long with context C<20>, then a representation of the stack is:

          Rule:    my_rule     =    I      J   'string terminal'
  --------------------------------------------------------------
  Stack indice:          0     =    0      1                   2
          Type:       LONG        PTR    INT               SHORT
       Context:         20         17    216                  43

You will note that:

=over

=item The context of the terminal is a short !?

The <'string terminal'> terminal is coming from input stream. There is I<no> associated symbol, and the function that manage symbols is covered by this grammar statement:

  :default ::= symbol-action => my_symbol_action

marpaESLIF called the symbol action resolver C<symbolActionResolverp> for action C<"my_symbol_action">, the later returning function pointer C<my_symbol_actionp>, and marpaESLIF called this function pointer like this:

  my_symbol_actionp(userDatavp, marpaESLIFValuep, p, l, 2)

where C<p> is a pointer to a copy of input stream C<'string terminal'>, of size C<l>, asking for the result to be pushed at stack indice number C<2>. It is the user that decided that it will put a short value at indice 2, with context C<43>.

=item You talk about value types and context in the stack, but B<how> can this be set?

marpaESLIF provide stack manipulation functions, and it is simply impossible for the end-user to manipulate the stack without using these functions. Stack itself is maintained inside marpaESLIF. Please see all C<marpaESLIFValue_stack_xxx> stack functions documented later.

=item Stack number indice C<0> is in I<both input and output> indices

This mean that, at any time, a stack indice can be replaced by another. This is a decision of the parse tree engine, based on rule definitions.

Suppose that valuation of rule C<my_rule>, there is already something at indice C<0> in the stack and it is a pointer!? marpaESLIF will I<automatically> call for I<memory free> action on this indice, before replacing it by the C<my_rule> result. The I<free action> is set at the grammar level:

  :default ::= free-action => my_free_action

=back

Full history of our example rule C<my_rule> action is then:

=over

=item 1 - Call the action resolver for C<"my_action">

The function call is equivalent to

  ruleActionResolverp(userDatavp, marpaESLIFValuep, "my_action")

We suppose that it returned a function pointer to C<my_actionp>, a function that exist in user-space.

=item 2 - Call C<my_actionp>

The function call is

  my_actionp(userDatavp, marpaESLIFValuep, 0/* arg0i */, 2/* argni */, 0/* resulti */, 0/* nullableb */)

What is this C<nullableb> flag!? Well, it means what it means: sometimes a rule is nullable, for example the empty rule:

  nullableRule ::= action => my_action2;

or a sequence rule:

  nullableRule ::= item* action => my_action2

Then, and only in these cases, the C<nullableb> flag is a true value, C<arg0i> and C<argni> will be both C<-1>, e.g. (with C<my_action2p> being the rule resolver result for action C<"my_action2">):

  my_action2p(userDatavp, marpaESLIFValuep, -1/* arg0i */, -1/* argni */, 0/* resulti */, 1/* nullableb */)

Ok, so finally C<my_actionp> is called, and it decided to return a value of type I<long> and context C<20>.

=item 3 - Call the free resolver for C<"my_free_action">

The function call is equivalent to

  freeActionResolverp(userDatavp, marpaESLIFValuep, "my_free_action")

Suppose that it returned a function pointer to C<my_free_actionp>, a function that exist in user-space.

=item 4 - Call C<my_free_actionp>

  my_free_actionp(userDatavp, 17, p, l)

where C<p> is a pointer to the memory holding previous value at stack indice C<0>. C<l> is zero in this case, we explain later when it can be different than zero. C<17> is the context, so that the function pointer C<my_free_actionp> knows what we are talking about.

=item 5 - Put user data at stack indice C<0> and context C<20>

=back

Nothing differentiate symbol actions v.s. rule action except that there is no range of indices in input, only a single indice.

Returns C<NULL> is no valuation is possible at this stage, else return a non-C<NULL> value.

=head3 C<marpaESLIFValue_recognizerp>

  marpaESLIFRecognizer_t *marpaESLIFValue_recognizerp(marpaESLIFValue_t *marpaESLIFValuep);

Returns the marpaESLIF's recognizer instance used to create the C<marpaESLIFValuep> instance.

=head3 C<marpaESLIFValue_optionp>

  marpaESLIFValueOption_t *marpaESLIFValue_optionp(marpaESLIFValue_t *marpaESLIFValuep);

Returns the options used to create the C<marpaESLIFValuep> instance, or C<NULL> if failure. The returned pointer must I<never> be freed.

=head3 C<marpaESLIFValue_valueb>

  short marpaESLIFValue_valueb(marpaESLIFValue_t       *marpaESLIFValuep,
                               marpaESLIFValueResult_t *marpaESLIFValueResultp);

Calls for parse tree valuation. Parameter C<marpaESLIFValueResultp> can be C<NULL>, meaning that the end-user is not interested by the value. Otherwise, this a pointer to a structure of type C<marpaESLIFValueResult_t> that will host the result. Technically, please note that a final parse tree valuation is <always> at stack indice number C<0>:

The return value of C<marpaESLIFValue_valueb> is always:

=over

=item 1 on success

=item 0 on end

=item -1 on failure

=back

I.e. a typical usage is:

  while (1) {
    short rcValueb = marpaESLIFValue_valueb(marpaESLIFValuep, NULL);
    if (rcValueb < 0) {
      goto err;
    } else if (rcValueb == 0) {
      break;
    }
  }

=head3 C<marpaESLIFValue_value_startb>

  short marpaESLIFValue_value_startb(marpaESLIFValue_t *marpaESLIFValuep, int *startip);

Taken directly from L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper> interface, this is returning the Start Earleme Set Ids of current valuation phase in the value pointed by C<startip>, if the later is not C<NULL>. This should be used to produce progress reports if wanted.

This method cannot be called outside a valuation callback. C.f. C<marpaESLIFValue_value_lengthb> for an example.

Returns a true value on success, else a false value.

=head3 C<marpaESLIFValue_value_lengthb>

  short marpaESLIFValue_value_lengthb(marpaESLIFValue_t *marpaESLIFValuep, int *lengthip);

Returns the number of Earleme Set Ids in the value pointed by C<lengthip>, if the later is not C<NULL>.

The length is greater than zero only when current Start Earleme Set Id is at a non-nullable symbol. This method cannot be called outside a valuation callback.

A typical usage example is:

  int starti;
  int lengthi;

  if (marpaESLIFValue_value_startb(marpaESLIFValuep, &starti) &&
      marpaESLIFValue_value_lengthb(marpaESLIFValuep, &lengthi)) {
      marpaESLIFRecognizer_progressLogb(marpaESLIFValue_recognizerp(marpaESLIFValuep),
                                        starti,
                                        /* lengthi is zero when this is a nullable symbol */
                                        (lengthi > 0) ? starti+lengthi-1 : starti,
                                        GENERICLOGGER_LOGLEVEL_ERROR);
    }

Returns a true value on success, else a false value.

=head3 C<marpaESLIFValue_contextb>

  short marpaESLIFValue_contextb(marpaESLIFValue_t  *marpaESLIFValuep,
                                 char              **symbolsp,
                                 int                *symbolip,
                                 char              **rulesp,
                                 int                *ruleip);

Puts in the value pointed by C<symbolsp> if it is not C<NULL>, the current symbol name if valuation occurs on a symbol, or in the value pointed by C<rulesp> if it is not C<NULL>, the current current rule name if valuation occurs on a rule. Idem for C<symbolip> and C<ruleip> concerning symbol Id and rule Id, respectively, where the value C<-1> is filled for cases that do not apply.

Returns a true value on success, a false value on failure.

=head3 C<marpaESLIFValue_freev>

  void marpaESLIFValue_freev(marpaESLIFValue_t *marpaESLIFValuep);

The destructor of a marpaESLIFValue instance C<marpaESLIFValuep> instance. No-op if C<marpaESLIFValuep> is C<NULL>.

=head2 Stack manipulation

In the valuation callbacks, stack is manipulated using the functions described below. With no exception, they all return a true value on success, a false value on failure, and all have in common current marpaESLIF valuation context C<marpaESLIFValuep>.

The I<getAndForget> versions are dangerous in the sense that there is a risk of memory leak if your application forget to free a memory popped from the stack with such method. Nevertheless, they are also very handy when wou I<know> this is a pointer that you want ESLIF to totally forget about.

=head3 C<marpaESLIFValue_stack_setb>

  short marpaESLIFValue_stack_setb(marpaESLIFValue_t *marpaESLIFValuep,
                                   int indicei,
                                   marpaESLIFValueResult_t *marpaESLIFValueResultp);

Puts the C<marpaESLIFValueResultp> pointer at stack number C<indicei>.

Returns a true value on success, a false value otherwise.

=head3 C<marpaESLIFValue_stack_forgetb>

  short marpaESLIFValue_stack_forgetb(marpaESLIFValue_t *marpaESLIFValuep,
                                      int indicei);

Says to ESLIF to forget about any eventual value result at indice C<indicei>.

Returns a true value on success, a false value otherwise.

=head3 C<marpaESLIFValue_stack_getb>

  marpaESLIFValue_stack_getb(marpaESLIFValue_t *marpaESLIFValuep,
                             int indicei,
                             marpaESLIFValueResult_t *marpaESLIFValueResultp);

Copies the value result at indice C<indicei> into the C<marpaESLIFValueResultp> pointer.

Returns a true value on success, a false value otherwise.

=head3 C<marpaESLIFValue_stack_getp>

  marpaESLIFValueResult_t *marpaESLIFValue_stack_getp(marpaESLIFValue_t *marpaESLIFValuep,
                                                      int indicei);

Gets a direct pointer to the value result at indice C<indicei> within the value stack. Handy method for performance.

Returns a non-C<NULL> value on success, C<NULL> otherwise.

=head3 C<marpaESLIFValue_stack_getAndForgetb>

  short marpaESLIFValue_stack_getAndForgetb(marpaESLIFValue_t *marpaESLIFValuep,
                                            int indicei,
                                            marpaESLIFValueResult_t *marpaESLIFValueResultp);

Puts the C<C>'s C<long> value C<l>, associated to context C<contexti> that must be different than zero, at stack number C<indicei>.

=head3 C<marpaESLIFValue_stack_set_floatb>

  short marpaESLIFValue_stack_set_floatb(marpaESLIFValue_t *marpaESLIFValuep,
                                         int                indicei,
                                         int                contexti,
                                         float              f);

Copies the value result at indice C<indicei> into the C<marpaESLIFValueResultp> pointer, and instruct ESLIF to forget about it.

Returns a true value on success, a false value otherwise.

=head1 NOTES

=over

=item Thread-safety

Any of the object of this API is thread-safe but is not I<reentrant>, except a C<marpaESLIF> instance. That is, if user need to access the same object from different threads, he is responsible of doing sychronization.

=item Grammar show form

The grammar show form is a concatenation of rule show forms and internal information, for every valid grammar level. For every grammar, the following is outputed:

=over

=item Meta grammar settings

For example:

  /*
   * **********************
   * Meta-grammar settings:
   * **********************
   */
  :start ::= json
  :default ::= action => ::concat
               symbol-action => ::shift
               latm => 1

=item Event settings

For example:

  /*
   * ***************
   * Event settings:
   * ***************
   */
  :lexeme ::= <lstring> pause => after event => lstring$=on

=item Rules

For example:

  /*
   * ******
   * Rules:
   * ******
   */
  <json> ::= <object>
  <json> ::= <array>
  <object> ::= '{' <members> '}' action => do_object
  etc...

=item Lexemes

A I<lexeme> is a symbol that is referencing another symbol of the same name but in <another> grammar level, for example:

  # --------
  # Lexemes:
  # --------
  #
  # <number> ::= <number>@+1
  # <lstring> ::= <lstring>@+1
  # <whitespace> ::= <whitespace>@+1

=item Rule properties

For every rule, Marpa parser internal properties are given, together with the rule description, and components of the rule in terms in symbol indices, for example:

  # -----------------
  # Rules properties:
  # -----------------
  #
  # Rule No 0
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <json> ::= <object>
  #   Components:  LHS = RHS[]
  #                  0 = 1
  # ...
  #
  # Rule No 2
  #   Properties: ACCESSIBLE, PRODUCTIVE
  #   Definition: <object> ::= '{' <members> '}' action => do_object
  #   Components:  LHS = RHS[]
  #                  1 = 3 4 5
  # Rule No 3
  #   Properties: ACCESSIBLE, NULLABLE, PRODUCTIVE
  #   Definition: <members> ::= <pair>* separator => /[,]/ action => do_array
  #   Components:  LHS = RHS[]
  #                  4 = 6
  #
  # ...

Exceptions are shown like this:

  #
  # Rule No 2
  #   Properties: ACCESSIBLE, NULLABLE, PRODUCTIVE
  #   Definition: <start> ::= <thisstart> - <startException>
  #   Components:  LHS = RHS[] - EXCEPTION
  #                  0 = 4 - 5
  #

=item Symbol properties

For every symbol, its ESLIF type, Marpa parser properties and definition are given. When it is a terminal, corresponding regular expression definition is given, as well as eventual JIT usage (c.f. PCRE2 information to understand what it is about). For example:

  # -------------------
  # Symbols properties:
  # -------------------
  #
  # Symbol No 0
  #         Type: ESLIF META
  #   Properties: ACCESSIBLE, PRODUCTIVE, START
  #         Name: <json>
  #
  # ...
  #
  # Symbol No 3
  #         Type: ESLIF TERMINAL
  #   Properties: ACCESSIBLE, PRODUCTIVE, TERMINAL
  #      Pattern: \{
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes
  #
  # ...
  #
  # Symbol No 23
  #         Type: ESLIF TERMINAL
  #   Properties: PRODUCTIVE, TERMINAL
  #      Pattern:
  #     0x000000: 5b 5c 73 5d                                     [\s]
  #        Flags: PCRE2_ANCHORED
  #          JIT: complete=yes, partial=yes

There are two types of terminal:

=over

=item Strings

Strings are always converted to a pattern that is fully ASCII compatible, in which ESLIF decide to eventually escape some characters, or to use them in their C<\x{...}> code point version. Therefore the definition of the PCRE2 pattern is outputed as-is.

=item Regular expression

This type include character class. In such a case, the UTF-8 byte sequence corresponding to what the grammar is defining is sent directly to PCRE2, so the definition is the dump of this UTF-8 byte sequence.

=back

=back

=back

=head1 SEE ALSO

L<genericLogger|https://github.com/jddurand/c-genericLogger>,  L<PCRE2|http://www.pcre.org/>, L<libmarpa|https://jeffreykegler.github.io/Marpa-web-site/libmarpa.html>, L<marpaWrapper|https://github.com/jddurand/c-marpaWrapper>
